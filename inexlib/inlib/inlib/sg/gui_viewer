// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file inlib.license for terms.

#ifndef inlib_sg_gui_viewer
#define inlib_sg_gui_viewer

#include "../platform"

#include "guiv"
#include "noderef"
#include "acbk"
#include "holder" //for m_tmp_group
#include "draw_style"
#include "_switch"
#include "ghost"
#include "style_parser"
#include "style"
#include "text_style"
#include "selection"
#include "torche"
#include "progress"
#include "slider"
#include "matrix"
#include "depth_test"
#include "ortho"
#include "perspective"
#include "frustum"
#include "lrbt"
#include "vertices"
#include "simple_button"
#include "button_grid"
#include "cube_manip"
#include "search"
#include "camera_anim"
#include "count_action"

#include "list"
#include "infos_box"
#include "scroll_text"
#include "scroll_infos"
#include "numeric"
#include "edvalop"
#include "entry"
#include "entries"
#include "colors"
#include "image_text_button"
#include "params2entries"
#include "enum2s"
#include "opener"
#include "../image_reader"

#include "../cbk/timer"
//#include "../cbk/none"

#include "../event_timer"
#include "../vpair"
#include "../mapmanip"

//#include "../wall/protocol" //fo set_wall_action_prots()

#include "fundata_cbk"
#include "gv_cbk"
#include "base_dumper"
#include "zb_manager"
#include "../atime2s"

//#ifdef _MSC_VER
//#pragma warning(disable:4355)
//#endif

namespace inlib {
namespace sg {

INLIB_GLOBAL_STRING(zoom_in_out)
INLIB_GLOBAL_STRING(zoom_in_out_rot)

class gui_viewer : public guiv {
  INLIB_HEADER(gui_viewer,inlib::sg::gui_viewer,guiv)
private:
  INLIB_CLASS_STRING(event_timer)
protected:  
  typedef std::vector<void*> ptrs_t;
public:
  static int SHOWN() {return 0;}
  static int HIDDEN() {return 1;}
public: //Android, iPhone.
  virtual void set_size(unsigned int a_w,unsigned int a_h) {
    //m_out << "debug : inlib::sg::gui_viewer::set_size :"
    //      << " ww " << a_w
    //      << " wh " << a_h
    //      << std::endl;
    parent::set_size(a_w,a_h);
    ask_to_rebuild_gui(); //should have a set_gui_layout().
    cursor_visible.touch();
  }

public: //alert
  virtual void warn(const std::string& a_msg,bool a_warn = true) {
    // if needed we could secure the execution in a work.
    map_warn(a_msg,a_warn);
  }
  virtual std::ostream& out_stream() const {return m_out;}
  virtual void show_console(const std::string& a_v) {
    m_console.set_label(a_v);
    show_console();
  }
public: //guib
  virtual void ask_to_rebuild_gui() {
    // invalidate cbks that contain pointer to buttons that are going to be deleted.
    invalidate_works(arm_work::s_class());
    invalidate_works(disarm_work::s_class());
    gui_visible.touch();
  }
  virtual render_manager* find_render_manager(const std::string&) {return 0;} //to find gl2ps_manager (see exlib/cbk/out).
public:
  virtual bool has_mail_panel() {return false;}
  virtual bool mail_panel(const std::string& /*a_to*/,
                          const std::string& /*a_subject*/,
                          const std::string& /*a_msg*/,
                          const std::string& /*a_path*/,
                          const std::string& /*a_mime*/){
    return false;
  }
  virtual bool has_open_panel() {return false;}
  virtual bool open_panel(std::string& a_path) {a_path.clear();return false;}
public: //OpenGL infos.
  // see exlib/sg/GL_VIEWER
  virtual void gl_infos(std::vector<std::string>& a_v) const {a_v.clear();}
public:
  template <class T>
  void num2console(const T& a_v) {    
    std::string stmp;
    if(!num2s(a_v,stmp)) {}
    m_console.set_label(stmp);
    show_console();
  }
  void atime2console(const atime& a_time) {
    std::string stmp = atime2s(a_time);
    m_console.set_label(stmp);
    //a_gv.m_params.m_console_width = 0.6F;
    //set_console_layout();
    show_console();
  }
  
public:
  virtual void clear_scene() {
    m_scene->clear();
    m_scene->clear_cbks();
    set_scene_camera(0);
    m_params.m_plane_viewer = true;
    m_params.m_cam_tiled = true;
    m_scene_light = 0;
    hide_sliders();    
    //stop_cam_anim();  //any cam_anim node are now deleted.
    //NOTE : we do not stop the event anim here. Someone may want to
    //       clear the scene for one event but continue to vis
    //       further events.
    //stop_event_anim();
  }

  // cursor :  
  virtual bool set_cursor_shape(cursor_shape a_shape) {
    cursor_model = a_shape;
    return true;
  }

  ///////////////////////////////////////////////////
  /// virtual for wall/screen_main : ////////////////
  ///////////////////////////////////////////////////

  virtual selection* create_selection() const {return new selection;}

  virtual base_camera* create_camera(camera_type a_type,float a_near_height,float a_near) {
    if(a_type==camera_ortho) {
      ortho* camera = new ortho;
      camera->height = a_near_height;
      camera->znear = a_near;
      return camera;
    } else if(a_type==camera_perspective) { 
      perspective* camera = new perspective;

      float angle = 2 * fatan((a_near_height*0.5f)/a_near);

      camera->height_angle = angle;
      camera->znear = a_near;

      return camera;
    } else {
      return 0;
    }   
  }

  // in case cam ortho, get one screen world coords size :
  virtual void get_gui_wcw_wch(float& a_wcw,float& a_wch,float& a_tx,float& a_ty,float& a_aspect) const {
    get_screen_wcw_wch(gui_camera_height(),0,0,a_wcw,a_wch,a_tx,a_ty,a_aspect);
    if(m_vr_mode) a_wcw *= 0.5;
  }

  virtual void get_screens(unsigned int& a_cols,unsigned int& a_rows){
    a_cols = 1;
    a_rows = 1;
  }

  virtual void get_screen_wcw_wch(float a_cam_height,
                                  unsigned int,unsigned int,
                                  float& a_wcw,float& a_wch,
                                  float& a_tx,float& a_ty,
                                  float& a_aspect) const {
    a_aspect = float(m_ww)/float(m_wh);
    a_wch = a_cam_height;
    a_wcw = a_wch*a_aspect;
    a_tx = 0;    
    a_ty = 0;    
  }

  virtual void get_gui_all_wcw_wch(float& a_wcw,float& a_wch) const {
    float aspect = float(m_ww)/float(m_wh);
    a_wch = gui_camera_height();
    a_wcw = a_wch*aspect;
  }

  virtual void get_inside_pixels(unsigned int& a_w,unsigned int& a_h) const {
    a_w = m_ww;
    a_h = m_wh;
  }

  virtual void screen_to_gui(int a_ix,int a_iy,float& a_x,float& a_y) const {
    // for popup.
    float aspect = float(m_ww)/float(m_wh);
    float wch = gui_camera_height();
    float wcw = wch*aspect;
    a_x = float(a_ix)*wcw/float(m_ww)-wcw*0.5f;
    a_y = float(a_iy)*wch/float(m_wh)-wch*0.5f;
  }

  virtual void toggle_camera_menu_at_pos(int,int) {toggle_camera_menu();}

  virtual bool treat_anim(const atime& a_t) {
    anim_event e(a_t.seconds(),a_t.micro_seconds());
    event_action action(m_out,m_ww,m_wh,e);
    m_sg.event(action);
    return e.some_found(); //someone did something with this event.
  }

  virtual void enable_anim() {
    if(has_valid_work(anim_work::s_class())) return;
    add_work(new anim_work(*this));
  }

  virtual void disable_anim() {invalidate_works(anim_work::s_class());}

  virtual void ask_to_sync_clients() {}

  virtual void wait_sync_client() {}

  virtual void clear_caches() {m_tmp_group.clear();}

  ////////////////////////////////////
  /// camedit panel : ////////////////
  ////////////////////////////////////
protected:
  virtual bool swap_scene_camera_kind(){
    if(!m_scene_camera) return false;

    base_camera* new_cam = 0;

    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      //have to find a correct value for an ortho height.

      ortho* new_oc = new ortho;
      new_oc->height = 2.0f*m_scene_camera->focal.value()*ftan(pc->height_angle.value()*0.5f);
      new_cam = new_oc;

    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      //have to find a correct value for a perspective angle_height.

      perspective* new_pc = new perspective;
      // we assume that ortho height "at focal" is a good parameter
      // to guess a reasonnable perspective height_angle.
      new_pc->height_angle = 2.0f*fatan2(0.5f*oc->height.value(),m_scene_camera->focal.value());
      new_cam = new_pc;

    } else {
      m_out << "inlib::sg::gui_viewer::swap_scene_camera_kind :"
            << " camera not ortho and not perspective."
            << std::endl;
      return false;
    }

    new_cam->znear = m_scene_camera->znear;
    new_cam->zfar = m_scene_camera->zfar;
    new_cam->position = m_scene_camera->position;
    new_cam->orientation = m_scene_camera->orientation;
    new_cam->dx = m_scene_camera->dx;
    new_cam->da = m_scene_camera->da;
    new_cam->ds = m_scene_camera->ds;
    new_cam->focal = m_scene_camera->focal;

    set_scene_camera(new_cam);

    return true;
  }
public:
  bool swap_camera_kind() {
    base_camera* cam = m_scene_camera;
    if(!cam) return false;
    group* grp = find_container<group>(m_out,*m_scene,*cam,false);
    if(!grp) return false;
    if(!swap_scene_camera_kind()) return false;
    base_camera* new_cam = m_scene_camera;
    return grp->replace(cam,new_cam,true);
  }  

public:
  virtual inlib::opener& opener() {return m_opener;} //inlib:: needed.

  image::readers& image_readers() {return m_image_readers;}
private:
  sf<bool> gui_visible;
public:

  sf<bool> cursor_visible;
  sf<float> cursor_line_width;
  sf_enum<cursor_shape> cursor_model;

  sf<bool> params_button_visible;
  sf<bool> camera_button_visible;

  sf<bool> camenu_edit_visible;
  sf<bool> camenu_90_visible;
  sf<bool> camenu_focal_visible;
  sf<bool> camenu_viewing_visible;
  sf<bool> camenu_view_all_visible;
public:
  gui_viewer(std::ostream& a_out,
             render_manager& a_gl_mgr,
             const base_freetype& a_ttf,    //template ttf node.
             const selection& a_selection,  //template selection node.
             unsigned int a_width,unsigned int a_height,
             bool a_verbose = false)
  :parent(a_out,a_width,a_height,a_verbose)

  ,gui_visible(true)
  ,cursor_visible(false)
  ,cursor_line_width(2)
  ,cursor_model(cursor_default)
  ,params_button_visible(true)
  ,camera_button_visible(true)

  ,camenu_edit_visible(true)
  ,camenu_90_visible(true)
  ,camenu_focal_visible(true)
  ,camenu_viewing_visible(true)
  ,camenu_view_all_visible(true)

  ,m_render_manager(a_gl_mgr)
  ,m_ttf(a_ttf)

  ,m_scene(0)

  ,m_scene_camera(0)
  ,m_reset_camera(0)
  ,m_scene_light(0)

  ,m_gui(0)

  ,m_camenu_shift_button(a_ttf)
  ,m_camenu_sshoot_text_button(a_ttf)
  ,m_camenu_90_text_button(a_ttf)
  ,m_camenu_focal_button(a_ttf)
  ,m_camenu_viewing_button(a_ttf)
  ,m_camenu_gsto_button(a_ttf)
  ,m_camenu_plane_exam_button(a_ttf)
  ,m_console(a_ttf)

  ,m_popup_cbks()

  ,m_meta_had_been_shown(false)

  ,m_tab_current(-1)

  ,m_touch_in_motion(false)
  ,m_touch_prev_x(0)
  ,m_touch_prev_y(0)

  ,m_gesture_begin_x(0)
  ,m_gesture_begin_y(0)
  ,m_gesture_begin_camera(0)

  ,m_motion_slider(0)

  ,m_treat_mouse_motion(false)

  ,m_cursor_camera(0)

  ,m_memory_warning(false)
  //,m_jpeg_data(a_out)

  ,m_action_prots()

  ,m_dumpers()
  ,m_opener(get_me(),0)
  ,m_vr_mode(false)  
  {
    m_scene = safe_cast<node,selection>(*(a_selection.copy()));
    m_gui = safe_cast<node,selection>(*(a_selection.copy()));

    //WARNING : in m_sg, m_scene_switch expected at 0, m_gui at 1.
    //          If changing that, look at touch_[down,up]().
    m_sg.add(new noderef(m_scene_switch));

    m_scene_switch.add(new noderef(*m_scene));
    m_scene_switch.add(new separator());
    m_scene_switch.which = gui_visible.value()?HIDDEN():SHOWN();

    //m_gui after m_scene because it disables depth test.
    // (But for picking it should be traversed first !)
    m_sg.add(new noderef(*m_gui));

    m_gui->down_cbks().add(new gv_cbk(*this,action_touch_down));
    m_gui->up_cbks().add(new gv_cbk(*this,action_touch_up));
    m_gui->move_cbks().add(new gv_cbk(*this,action_touch_move));

    //m_gui->stop_at_first = true; //FIXME : because of buttons.
    //m_gui->verbose = true;

    m_sg.add(new noderef(m_cursor));

    m_main_menu_switch.which = gui_visible.value()?SHOWN():HIDDEN();
    m_camenu_switch.which = HIDDEN();
    m_gui_sliders_switch.which = HIDDEN();
    m_sliders_switch.which = HIDDEN();
    m_progress_switch.which = HIDDEN();
    m_console_switch.which = HIDDEN();
    m_popup_switch.which = HIDDEN();
    m_meta_switch.which = HIDDEN();
    m_cursor_switch.which = HIDDEN();

    m_cursor_matrix.set_identity();

    set_arconf(m_console,"");
    m_console.hjust = sg::left;
    m_console.confine = false;
    m_console.add_callback
      (new fundata_cbk<gui_viewer,_switch,pos_data>(*this,m_console_switch,action_hide,pos_data(false,0,0)));

    // set default gsto mode on m_params :
    gsto_mode2s(m_render_manager.get_gsto_mode(),m_params.m_gsto_mode);
  }
  virtual ~gui_viewer(){
    safe_clear<std::string,base_dumper>(m_dumpers);
    delete m_reset_camera;
    delete m_gesture_begin_camera;
    delete m_scene;
    delete m_gui;
  }
protected:
  gui_viewer(const gui_viewer& a_from)
  :ui(a_from)
  ,alert(a_from)
  ,parent(a_from)

  ,gui_visible(a_from.gui_visible)
  ,cursor_visible(a_from.cursor_visible)
  ,cursor_line_width(a_from.cursor_line_width)
  ,cursor_model(a_from.cursor_model)
  ,params_button_visible(a_from.params_button_visible)
  ,camera_button_visible(a_from.camera_button_visible)

  ,camenu_edit_visible(a_from.camenu_edit_visible)
  ,camenu_90_visible(a_from.camenu_90_visible)
  ,camenu_focal_visible(a_from.camenu_focal_visible)
  ,camenu_viewing_visible(a_from.camenu_viewing_visible)
  ,camenu_view_all_visible(a_from.camenu_view_all_visible)

  ,m_render_manager(a_from.m_render_manager)
  ,m_ttf(a_from.m_ttf)

  ,m_scene(0)

  ,m_scene_camera(0)
  ,m_reset_camera(0)
  ,m_scene_light(0)

  ,m_gui(0)

  ,m_camenu_shift_button(m_ttf)
  ,m_camenu_sshoot_text_button(m_ttf)
  ,m_camenu_90_text_button(m_ttf)
  ,m_camenu_focal_button(m_ttf)
  ,m_camenu_viewing_button(m_ttf)
  ,m_camenu_gsto_button(m_ttf)
  ,m_camenu_plane_exam_button(m_ttf)
  ,m_console(m_ttf)

  ,m_popup_cbks(a_from.m_popup_cbks)

  ,m_meta_had_been_shown(false)

  ,m_touch_in_motion(false)
  ,m_touch_prev_x(0)
  ,m_touch_prev_y(0)

  ,m_gesture_begin_x(0)
  ,m_gesture_begin_y(0)
  ,m_gesture_begin_camera(0)

  ,m_motion_slider(0)

  ,m_treat_mouse_motion(false)

  ,m_cursor_camera(0)

  ,m_memory_warning(false)

  ,m_action_prots(a_from.m_action_prots)

  //,m_jpeg_data(a_from.m_out)
  ,m_dumpers()
  ,m_opener(a_from.m_opener)
  ,m_image_readers(a_from.m_image_readers)
  ,m_vr_mode(a_from.m_vr_mode)
  ,m_argcv(a_from.m_argcv)
  {
    //m_scene = safe_cast<node,selection>(*(a_from.m_scene->copy()));
    //m_gui = safe_cast<node,selection>(*(a_from.m_scene->copy()));
    //m_scene->clear();    
    //m_gui->clear();

    delete m_reset_camera;
    m_reset_camera = a_from.m_reset_camera?a_from.m_reset_camera->copy():0;

    copy<std::string,base_dumper>(m_dumpers,a_from.m_dumpers);
  }

  gui_viewer& operator=(const gui_viewer& a_from){
    parent::operator=(a_from);

    if(&a_from==this) return *this;
    
    gui_visible = a_from.gui_visible;
    cursor_visible = a_from.cursor_visible;
    cursor_line_width = a_from.cursor_line_width;
    cursor_model = a_from.cursor_model;
    params_button_visible = a_from.params_button_visible;
    camera_button_visible = a_from.camera_button_visible;

    camenu_edit_visible = a_from.camenu_edit_visible;
    camenu_90_visible = a_from.camenu_90_visible;
    camenu_focal_visible = a_from.camenu_focal_visible;
    camenu_viewing_visible = a_from.camenu_viewing_visible;
    camenu_view_all_visible = a_from.camenu_view_all_visible;

    m_scene_camera = 0;    

    delete m_reset_camera;
    m_reset_camera = a_from.m_reset_camera?a_from.m_reset_camera->copy():0;
    m_scene_light = 0;

    m_popup_cbks = a_from.m_popup_cbks;

    m_meta_had_been_shown = false;

    m_touch_in_motion = false;
    m_touch_prev_x = 0;
    m_touch_prev_y = 0;

    m_gesture_begin_x = 0;
    m_gesture_begin_y = 0;
    m_gesture_begin_camera = 0;

    m_motion_slider = 0;

    m_treat_mouse_motion = false;

    m_cursor_camera = 0;

    m_memory_warning = false;

    m_action_prots = a_from.m_action_prots;

    copy<std::string,base_dumper>(m_dumpers,a_from.m_dumpers);

    m_vr_mode = a_from.m_vr_mode;
    m_argcv = a_from.m_argcv;

    return *this;
  }
public:
  const gui_viewer& get_me() const {return *this;}
  gui_viewer& get_me() {return *this;}
 
  const base_freetype& ttf() const {return m_ttf;}

  sg::zb_manager& zb_manager() {return m_zb_mgr;}

  //void set_vr_mode(bool a_value) {
  //  m_vr_mode = a_value;
  //  ask_to_rebuild_gui();
  //}
  //bool vr_mode() const {return m_vr_mode;}
public:   

  ///////////////////////////////////////////////////
  /// wall : for communication with data_client : ///
  ///////////////////////////////////////////////////

  typedef std::map<unsigned int,std::string> action_prots_t;
  const action_prots_t& action_prots() const {return m_action_prots;}
  //action_prots_t& action_prots() {return m_action_prots;}

  bool find_prot_action(const std::string& a_prot,unsigned int& a_action) {
    // used in wall/screen_dispatch :
    std::map<unsigned int,std::string>::const_iterator it;
    for(it=m_action_prots.begin();it!=m_action_prots.end();++it){
      if((*it).second==a_prot) {
        a_action = (*it).first;
        return true;
      }
    }
    a_action = 0;
    return false;
  }

/* previously used in exlib/app/wall_client :
  void set_wall_action_prots() {
    //used by wall_screen and wall data client programs.

    // See wall/screen_dispatch/EVT_USER_COMMAND.
    //IMPORTANT : action id must be the gui_viewer::gui_cbk ones.

    m_action_prots[gui_cbk::action_single_shoot()] = wall::protocol::s_rwc_single_shoot();
    m_action_prots[gui_cbk::action_90()] = wall::protocol::s_rwc_90();
    m_action_prots[gui_cbk::action_anim_shift()] = wall::protocol::s_rwc_anim_shift();
    m_action_prots[gui_cbk::action_anim_around_focal()] = wall::protocol::s_rwc_anim_around_focal();
    m_action_prots[gui_cbk::action_viewing()] = wall::protocol::s_rwc_viewing();

    m_action_prots[gui_cbk::action_reset_camera()] = wall::protocol::s_rwc_reset_camera();

    m_action_prots[gui_cbk::action_left()] = wall::protocol::s_rwc_left();
    m_action_prots[gui_cbk::action_right()] = wall::protocol::s_rwc_right();
    m_action_prots[gui_cbk::action_up()] = wall::protocol::s_rwc_up();
    m_action_prots[gui_cbk::action_down()] = wall::protocol::s_rwc_down();

    m_action_prots[gui_cbk::action_clear_scene()] = wall::protocol::s_rwc_clear_scene();

    m_action_prots[gui_cbk::action_cam_anim_zoom_in_out()] = wall::protocol::s_rwc_cam_anim_zoom_in_out();
    m_action_prots[gui_cbk::action_cam_anim_zoom_in_out_rot()] = wall::protocol::s_rwc_cam_anim_zoom_in_out_rot();
  }
*/
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////

  virtual void set_event_anim(event_timer* a_timer) { //get ownership. //virtual for WebGL
    add_in_tmp_group<event_timer>(s_event_timer(),a_timer);  
    add_work(new cbk::timer(*this,*a_timer));
  }

  void stop_event_anim() { // Used in exlib/[pmx,agora,cbk/lhc1].
    cbk::timer::invalidate_timer_works(*this,event_timer::s_class());
    remove_in_tmp_group<base_timer>(s_event_timer());
  }

  node* create_to_stop_event_anim_holder() { //see exlib/geant4/exas for an example.
    return new holder<to_stop_event_anim>(new to_stop_event_anim(*this));
  }     
  ///////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////

  const selection& sg_ui() const {return *m_gui;}
  selection& sg_ui() {return *m_gui;}

  void arm_button(base_button* a_node) {
    add_work(new arm_work(*this,a_node));
    m_arm_buttons.push_back(a_node);
  }
  void trigger_button(base_button* a_node) {
    add_work(new disarm_work(*this,a_node));
    add_work_cbks(a_node->cbks().callbacks(),true);    
  }

  selection& scene() {return *m_scene;}
  const selection& scene() const {return *m_scene;}

  bool scene_center(vec3f& a_center) {
    bbox_action action(m_out);
    m_scene->bbox(action);
    if(!action.end()) {
      m_out << "inlib::sg::gui_viewer::scene_center :"
            << " bad bbox_action end."
            << std::endl;
      a_center.set_value(0,0,0);
      return false;
    }
    return action.box().center(a_center);
  }

  ////////////////////////////////////////////
  /// special scene nodes ////////////////////
  ////////////////////////////////////////////
  torche* scene_light() const {return m_scene_light;}
  void set_scene_light(torche* a_light) {
    //we don't get ownership of a_light.
    m_scene_light = a_light;
    if(m_scene_light) m_scene_light->on = m_params.m_light_on;
  }

  bool set_scene_light_on(bool a_value) {
    if(!m_scene_light) return false;
    m_scene_light->on = a_value;
    m_params.m_light_on = a_value; //keep in sync.
    return true;
  }

  void set_use_gsto(bool a_value) {
    m_use_gsto = a_value;
    m_params.m_use_gsto = a_value; //keep in sync m_params.

   {typedef sg::gsto_mode mode_t;
    mode_t mode;
    if(!s2gsto_mode(m_params.m_gsto_mode,mode)){
      m_out << "inlib::sg::gui_viewer::set_use_gsto :"
            << " unknown gsto mode " << m_params.m_gsto_mode << "."
            << std::endl;
    }
    m_render_manager.set_gsto_mode(mode);
    if(m_render_manager.get_gsto_mode()!=mode) {
      //m_out << "inlib::sg::gui_viewer::set_use_gsto :"
      //      << " gsto mode " << m_params.m_gsto_mode
      //      << " not accepted by the gl manager."
      //      << std::endl;
    }}

    // the gl manager may refuse the given value :    
    gsto_mode2s(m_render_manager.get_gsto_mode(),m_params.m_gsto_mode);

    if(m_params.m_use_gsto) {
      m_camenu_gsto_button.back_area::color = colorf_pink();
      //m_params.m_gui_button_active_color;
    } else {
      m_camenu_gsto_button.back_area::color = m_params.m_gui_back_color;
    }

  }

  ////////////////////////////////////////////
  /// camera /////////////////////////////////
  ////////////////////////////////////////////
  base_camera* scene_camera() const {return m_scene_camera;}

  void set_scene_camera(base_camera* a_camera,bool a_set_reset_cam = true) {
    //we don't get ownership of a_camera.
    m_scene_camera = a_camera;
    _set_params_camera();    

    if(a_set_reset_cam){
      delete m_reset_camera;
      m_reset_camera = a_camera?a_camera->copy():0;
    }
  }

/*
  float scene_camera_radius() {
    if(!m_scene_camera) return 10000; //10*m A01

    ortho* oc = safe_cast<node,ortho>(*m_scene_camera);
    if(oc) return oc->height;

    perspective* pc = safe_cast<node,perspective>(*m_scene_camera);
    if(pc) {
      //reverse of exlib/opener/exsg_create_camera.
      float pos = pc->position.value().length();
      return pos * ftan(pc->height_angle.value()*0.5f);
    }     

    return 10000; //10*m A01
  }     
*/

  void start_anim_around_focal() { //for exlib/cbk/anim
    if(!m_params.m_anim_around_focal) {
      bcbk* cbk = new gv_cbk(*this,action_toggle_param_anim_around_focal);
      cbk->action();
      delete cbk;
    }
    bcbk* cbk = new gv_cbk(*this,action_right);
    cbk->action();
    delete cbk;
  }

  void update_anim_motion(anim_what a_anim,bool a_shift) {
    int move;
    if(!anim2motion(a_anim,a_shift,move)) return;
    update_motion(move);
    hide_meta_zone();
  }
private:
  void update_motion(int a_what) {
    if(!m_scene_camera) return;

    float dx = m_scene_camera->dx;
    float da = m_scene_camera->da;
    float ds = m_scene_camera->ds;

    if(a_what==move_rotate_right) {
      m_scene_camera->rotate_around_up(-da);
    } else if(a_what==move_rotate_left) {
      m_scene_camera->rotate_around_up(da);

    } else if(a_what==move_translate_right) {
      m_scene_camera->translate_along_side(dx);
    } else if(a_what==move_translate_left) {
      m_scene_camera->translate_along_side(-dx);

    } else if(a_what==move_up) {
      m_scene_camera->translate_along_up(dx);
    } else if(a_what==move_down) {
      m_scene_camera->translate_along_up(-dx);

    } else if(a_what==move_forward) {
      m_scene_camera->translate_along_dir(dx);
    } else if(a_what==move_backward) {
      m_scene_camera->translate_along_dir(-dx);

    } else if(a_what==move_zoom_in) {
      m_scene_camera->zoom(ds);
    } else if(a_what==move_zoom_out) {
      m_scene_camera->zoom(1.0f/ds);

    } else if(a_what==move_rotate_around_focal_right) {
      m_scene_camera->rotate_around_y_at_focal(-da);

    } else if(a_what==move_rotate_around_focal_left) {
      m_scene_camera->rotate_around_y_at_focal(da);

    }

  }
public:
  ////////////////////////////////////////////
  /// scene operations ///////////////////////
  ////////////////////////////////////////////
/*
  void delete_manips() {
    typedef search_action::path_t path_t;
    typedef search_action::paths_t paths_t;
    typedef cube_manip cm_t;

    search_action sa(m_out);
    const paths_t& paths = find_paths<cm_t>(sa,*m_scene);

    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        m_out << "gui_viewer::delete_manips :"
                      << " cube_manip parent group not found."
                      << std::endl;       
      } else {
        cm_t* cm = tail<cm_t>(p);
        if(!cm) {
          m_out << "inlib::sg::gui_viewer::delete_manips :"
                        << " cube_manip path with bad tail."
                        << std::endl;       
        } else {
          node* parent;
          node* node;
          cm->get_node(parent,node);
          if(!parent||!node) {
            m_out << "inlib::sg::gui_viewer::delete_manips :"
                          << " cube_manip without a maniped node."
                          << std::endl;       
          }
          
          matrix* m = new matrix;
          m->mtx = cm->mtx;
          grp->replace(cm,m,true); // it deletes cm.
           
          if(parent && node) {
            group* pgrp = safe_cast<node,group>(*parent);
            if(pgrp && pgrp->remove(node)) {
              delete node;          
            } else {
              m_out << "inlib::sg::gui_viewer::delete_manips :"
                            << " maniped node not in the expected parent."
                            << std::endl;       
            }
          }
        }
      }
    }    
    
  }
*/

  void remove_manips() {
    // but do not delete the working node.

    typedef cube_manip cm_t;

    search_action sa(m_out);
    const paths_t& paths = find_paths<cm_t>(sa,*m_scene);

    paths_t::const_iterator it;
    for(it=paths.begin();it!=paths.end();++it) {
      const path_t& p = *it;
      group* grp = container<group>(p);
      if(!grp) {
        m_out << "inlib::sg::gui_viewer::reset_manips :"
                      << " cube_manip parent group not found."
                      << std::endl;       
      } else {
        cm_t* cm = tail<cm_t>(p);
        if(!cm) {
          m_out << "inlib::sg::gui_viewer::reset_manips :"
                        << " cube_manip path with bad tail."
                        << std::endl;       
        } else {
          matrix* m = new matrix;
          m->mtx = cm->m_start_matrix;
          grp->replace(cm,m,true); // it deletes cm.
        }
      }
    }    
  }

  void count_points() {
    count_action ca(m_out);
    m_scene->bbox(ca);
    //show_console(ca.number_of_points());

    std::string s;
    s += "pts ";
    if(!numas<unsigned int>(ca.number_of_points(),s)){}
    s += ",gsto ";
    if(!numas<uint64>(m_render_manager.gstos_size(),s)) {}
    s += ",tex ";
    if(!numas<uint64>(m_render_manager.used_texture_memory(),s)) {}
    //m_out << s << std::endl;
    show_console(s);

    m_params.m_console_width = 0.6F;
    set_console_layout();
  }

  bool is_cursor_visible() {
    visible_action va(m_out,m_ww,m_wh);
    m_cursor.is_visible(va);
    unsigned int visibles = va.count();
    return visibles?true:false;
  }

  std::string anim_shift_button_label() const {
    //logic must be in sync with the below update_anim_motion. 
    if(m_params.m_camera_type.empty()) return "nil";

    if(m_params.m_plane_viewer) {
      if(m_params.m_anim_shift) {
        return "P/Z"; //P=Pane, Z=Zoom
      } else {
        return "P";
      }
    } else { //exam viewer.
      if(m_params.m_anim_shift) {
        return "P";
      } else {
        if(m_params.m_camera_type==s_camera_ortho()){
          return "R/Z"; //R=Rotate.
        } else {
          return "R/T"; //T=Translate (in z)
        }
      }
    }
  }

  ////////////////////////////////////////////
  /// gui style //////////////////////////////
  ////////////////////////////////////////////
protected:
  INLIB_CLASS_STRING(gui)

public:
/*
  void list_add(list& a_list,
                const std::string& a_label,
                const std::string& a_img_file,
                bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(a_img_file,img)) {
        a_list.add(a_label,img,a_cbk);
      } else {
        a_list.add(a_label,a_cbk);
      }
    } else {
      a_list.add(a_label,a_cbk);
    }
  }

  void list_white_add(list& a_list,
                      const std::string& a_label,
                      bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(s_white_jpg(),img)) {
        a_list.add(a_label,img,a_cbk);
      } else {
        a_list.add(a_label,a_cbk);
      }
    } else {
      a_list.add(a_label,a_cbk);
    }
  }

  void list_add_before(list& a_list,
                       const std::string& a_what,
                       const std::string& a_label,
                       const std::string& a_img_file,
                       bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(a_img_file,img)) {
        a_list.add_before(a_what,a_label,img,a_cbk);
      } else {
        a_list.add_before(a_what,a_label,a_cbk);
      }
    } else {
      a_list.add_before(a_what,a_label,a_cbk);
    }
  }

  void list_add_after(list& a_list,
                      const std::string& a_what,
                      const std::string& a_label,
                      const std::string& a_img_file,
                      bcbk* a_cbk){
    if(m_params.m_image_buttons) {
      img_byte img;
      if(set_img_from_res_file(a_img_file,img)) {
        a_list.add_after(a_what,a_label,img,a_cbk);
      } else {
        a_list.add_after(a_what,a_label,a_cbk);
      }
    } else {
      a_list.add_after(a_what,a_label,a_cbk);
    }
  }
*/

  bool anim2motion(anim_what a_anim,bool a_shift,int& a_move) {
    if(a_anim==anim_left) {
      if(m_params.m_plane_viewer) {
        a_move = move_translate_left;
        return true;
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_translate_left;
          return true;
        } else {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_left;
            return true;
          } else {
            a_move = move_rotate_left;
            return true;
          }
        }
      }

    } else if(a_anim==anim_right) {
      if(m_params.m_plane_viewer) {
        a_move = move_translate_right;
        return true;
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_translate_right;
          return true;
        } else {
          if(m_params.m_anim_around_focal) {
            a_move = move_rotate_around_focal_right;
            return true;
          } else {
            a_move = move_rotate_right;
            return true;
          }
        }
      }

    } if(a_anim==anim_up) {
      if(m_params.m_plane_viewer) {
        if(a_shift) {
          a_move = move_zoom_in;
          return true;
        } else {
          a_move = move_up;
          return true;
        }
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_up;
          return true;
        } else {
          if(m_params.m_camera_type==s_camera_ortho()){
            a_move = move_zoom_in;
            return true;
          } else {
            a_move = move_forward;
            return true;
          }
        }
      }

    } if(a_anim==anim_down) {
      if(m_params.m_plane_viewer) {
        if(a_shift) {
          a_move = move_zoom_out;
          return true;
        } else {
          a_move = move_down;
          return true;
        }
      } else { //exam viewer.
        if(a_shift) {
          a_move = move_down;
          return true;
        } else {
          if(m_params.m_camera_type==s_camera_ortho()){
            a_move = move_zoom_out;
            return true;
          } else {
            a_move = move_backward;
            return true;
          }
        }
      }
    }
    a_move = 0;
    return false;
  }

  ////////////////////////////////////////////
  ////////////////////////////////////////////
  ////////////////////////////////////////////

  void set_slider_style(slider& a_node) const {
    a_node.back_area::color = m_params.m_gui_back_color;
    a_node.back_area::border_color = m_params.m_gui_border_color;
    //a_node.color = m_params.m_gui_front_color;
    //a_node.arm_color = m_params.m_gui_arm_color;
    a_node.color = m_params.m_gui_arm_color;
  }
  void set_style(text& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(scroll_text& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(scroll_infos& a_node) const {
    a_node.back_area::color = m_params.m_gui_text_back_color;
    a_node.back_area::border_color = m_params.m_gui_text_border_color;
    a_node.color = m_params.m_gui_text_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(list& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.dir_color = m_params.m_gui_dir_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.label_back_color = m_params.m_gui_label_back_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(entries& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.labels_back_color = m_params.m_gui_label_back_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(entry& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(numeric& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(keyboard& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }  
  void set_style(edvalop& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  void set_style(colors& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.front_color = m_params.m_gui_front_color;
    a_node.arm_color = m_params.m_gui_arm_color;
    a_node.font = m_params.m_gui_font;
    a_node.font_modeling = m_params.m_gui_font_modeling;
  }
  
  typedef button_grid<simple_button> sbg_t;
  void set_colors(button_grid<simple_button>& a_node) const {
    a_node.back_color = m_params.m_gui_back_color;
    a_node.border_color = m_params.m_gui_border_color;
    a_node.arm_color = m_params.m_gui_arm_color;
  }
  void set_arconf(text& a_text,const std::string& a_s){
    a_text.strings.clear();
    a_text.strings.add(a_s);
    a_text.font = m_params.m_gui_font;
    a_text.font_modeling = m_params.m_gui_font_modeling;
    a_text.confine = true;
    a_text.hjust = center;
  }
  static void set_arconf(const gui_params& a_params,text& a_text,const std::string& a_s){
    a_text.strings.clear();
    a_text.strings.add(a_s);
    a_text.font = a_params.m_gui_font;
    a_text.font_modeling = a_params.m_gui_font_modeling;
    a_text.confine = true;
    a_text.hjust = center;
  }

  void set_text_layout(text& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    a_node.width = a_wcw*0.7F;

    float havailable = a_wch-2*a_hbutton;

   {size_t linen = a_node.strings.size();
    float h = linen*a_hbutton*0.8F;
    if(h>=havailable) h = havailable*0.95f;
    a_node.height = h;}

    float y = a_wch*0.5f-havailable*0.5f;
    a_mtx.set_translate(0,y,0);

    a_node.corner_radius = m_params.m_corner_radius;
  //a_node.confine = true;
  }

  void set_back_area_layout(back_area& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    a_node.width = a_wcw*0.5F;

    float havailable = a_wch-2*a_hbutton;

   {float h = a_wch*0.5f;
    if(h>=havailable) h = havailable*0.95f;
    a_node.height = h;}

    float y = a_wch*0.5f-havailable*0.5f;
    a_mtx.set_translate(0,y,0);

    a_node.corner_radius = m_params.m_corner_radius;
  }

  void set_scroll_text_layout(scroll_text& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
  //float wscroll = a_wcw*0.08f;
    float wscroll = a_hbutton;

    // fix margin and get wtext :
    float wmargin = a_wcw*0.01f;
    //We should have : 2*wmargin+wtext+wscroll*1.2 = wcw;
    float wtext = a_wcw-wscroll*1.2f-2.0f*wmargin;

    float hmargin = a_wch*0.01f;
    float hscroll = a_wch-2*a_hbutton-2*hmargin;

    float x = -(a_wcw-wtext)*0.5f+wmargin; //at left+margin.
    float y = a_wch*0.5f-hmargin-hscroll*0.5f;
    a_mtx.set_translate(x,y,0);

    a_node.width = wtext;
    a_node.height = hscroll;
    a_node.scroll_width = wscroll;
    a_node.visible_items = 20;
    a_node.confine = true;
    a_node.wmargin_factor = 0.98f;
    a_node.hmargin_factor = 0.98f;
  }

  void set_base_list_layout(base_list& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    a_node.visible_items = m_params.m_list_visible_items;
    a_node.text_common_height = true;

    a_node.width = a_wcw*0.7F; //round style needs space.
    a_node.scroll_width = a_hbutton;

    float hmargin = 0.05f*a_hbutton;
    float havailable = a_wch-2*a_hbutton-2*hmargin;

    unsigned int nitem = a_node.visible_items;
    float hwanted = nitem*a_hbutton;
    float hlist = mn<float>(hwanted,havailable);

    a_node.height = hlist;
        
    float y = a_wch*0.5f-havailable*0.5f-hmargin;
    // x center relative to central list (not taking into account right arrows)
    float x = a_node.width*0.5f-a_node.witem()*0.5f;

    a_mtx.set_translate(x,y,0);
  }

  //virtual for ArcheryTune.
  virtual void set_list_layout(list& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    set_base_list_layout(a_node,a_wcw,a_wch,a_hbutton,a_mtx);
    a_node.text_hmargin_factor = 0.5f; //Apple
    s2layout_policy(m_params.m_list_item_layout,a_node.item_layout.value());
    a_node.corner_radius = m_params.m_corner_radius;
  }

  void set_scroll_infos_layout(scroll_infos& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {

  //float wscroll = a_wcw*0.08f;
    float wscroll = a_hbutton;

  //float wtext = wcw*0.8f;
  //float wsctxt = wtext+wscroll*0.2f+wscroll; //scroll_text::update_sg
  //float wmargin = (wcw-wsctxt)*0.2f;

    // fix margin and get wtext :
    float wmargin = a_wcw*0.01f;
    //We should have : 2*wmargin+wtext+wscroll*1.2 = wcw;
    float wtext = a_wcw-wscroll*1.2f-2.0f*wmargin;

    float hmargin = a_wch*0.01f;
    float hscroll = a_wch-2*a_hbutton-2*hmargin;

    float x = -(a_wcw-wtext)*0.5f+wmargin; //at left+margin.
    float y = a_wch*0.5f-hmargin-hscroll*0.5f;
    a_mtx.set_translate(x,y,0);

    a_node.width = wtext;
    a_node.height = hscroll;
    a_node.scroll_width = wscroll;
    a_node.visible_items = 20;
    a_node.confine = true;
    a_node.wmargin_factor = 0.98f;
    a_node.hmargin_factor = 0.98f;

  }

  void set_edvalop_layout(edvalop& a_node,float a_wcw,float a_wch,float a_hbutton,matrix&) const {
    a_node.width = a_wcw*0.7F;
    a_node.height = a_wch*0.5F;

    a_node.text_hmargin_factor = 0.5f; //Apple
    a_node.numeric_width = a_wcw*0.7f;
    a_node.numeric_height = a_wch*0.5f;
    a_node.list_width = a_wcw*0.5f;
    a_node.list_height = a_wch*0.5f;
  //a_node.list_scroll_width = a_wch*0.5f*0.2f;
    a_node.list_scroll_width = a_hbutton;
  }

  //virtual for ArcheryTune.
  virtual void set_entries_layout(entries& a_node,float a_wcw,float a_wch,float a_hbutton,matrix& a_mtx) const {
    set_base_list_layout(a_node,a_wcw,a_wch,a_hbutton,a_mtx);

    a_node.text_hmargin_factor = 0.5f; //Apple
    a_node.corner_radius = m_params.m_corner_radius;

    a_node.numeric_width = a_wcw*0.7F;
    a_node.numeric_height = a_wch*0.5f;
    a_node.keyboard_width = a_wcw*0.98F;
    a_node.keyboard_height = a_wch*0.5f;
    a_node.colors_width = a_wcw*0.8F;
    a_node.colors_height = a_wch*0.5f;
    a_node.edvalop_width = a_wcw*0.8F;
    a_node.edvalop_height = a_wch*0.5f;
    a_node.file_chooser_width = a_wcw*0.8F;
    a_node.file_chooser_height = a_wch*0.5f;
    a_node.list_width = a_wcw*0.5F;
    a_node.list_height = a_wch*0.5F;
  //a_node.list_scroll_width = a_wcw*0.5F*0.2F;
    a_node.list_scroll_width = a_hbutton;

    // entries need more space than a list :
    a_node.width = a_wcw*0.9f;
    a_node.buttons_to_arrows_factor = 0.1f;
  //a_node.entry_label_result_factor = 0.7f;

    // x center relative to the whole widget (taking into account right arrows)
    a_mtx.set_translate(0,a_mtx.mtx.value().v13(),a_mtx.mtx.value().v23());

  }  

  bool ui_visible() {
    return (m_main_menu_switch.which.value()==SHOWN()?true:false);
  }
  bool camenu_visible() {
    return (m_camenu_switch.which.value()==SHOWN()?true:false);
  }
  bool sliders_visible() {
    return (m_sliders_switch.which.value()==SHOWN()?true:false);
  }
  bool popup_visible() {
    return (m_popup_switch.which.value()==SHOWN()?true:false);
  }

  // two method to hide scene when in rwc.
/*
  void save_scene()    {
    m_backup_scene.transfer(m_scene);

    m_backup_scene.up_cbks().copy(m_scene->up_cbks());
    m_backup_scene.down_cbks().copy(m_scene->down_cbks());
    m_backup_scene.move_cbks().copy(m_scene->move_cbks());
    m_scene->clear_cbks();
  } 
  void restore_scene() {
    m_scene->transfer(m_backup_scene);

    m_scene->up_cbks().copy(m_backup_scene.up_cbks());
    m_scene->down_cbks().copy(m_backup_scene.down_cbks());
    m_scene->move_cbks().copy(m_backup_scene.move_cbks());
    m_backup_scene.clear_cbks();
  }
*/

  void set_scene_clear_color(const colorf& a_color) {
    m_params.m_scene_screen_color = a_color;
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      m_clear_color = m_params.m_scene_screen_color;
    }
  }

  void set_scene_clear_color(float a_r,float a_g,float a_b,float a_a = 1) {
    set_scene_clear_color(colorf(a_r,a_g,a_b,a_a));
  }  
 
  void swap_scene_clear_color() {
    if(m_params.m_scene_screen_color==colorf_white()) {
      set_scene_clear_color(colorf_black());
    } else /*if(m_params.m_scene_screen_color==colorf_black())*/ {
      set_scene_clear_color(colorf_white());
    }
  }

  //virtual
  void show_main_menu() {
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      m_main_menu_switch.which = SHOWN();
      m_clear_color = m_params.m_gui_screen_color;
      m_meta_switch.which = HIDDEN();
      if(m_params.m_auto_hide_scene) m_scene_switch.which = HIDDEN();
      m_gui_sliders_switch.which = HIDDEN(); //do not traverse scene sliders
      hide_popup();
    }
  }

  bool main_menu_shown() {
    return m_main_menu_switch.which.value()==SHOWN()?true:false;
  }

  bool scene_shown() {
    return m_scene_switch.which.value()==SHOWN()?true:false;
  }

  //void show_scene() {m_scene_switch.which = SHOWN();}  //used in wall/scene_dispatch
  //void hide_scene() {m_scene_switch.which = HIDDEN();} //used in wall/scene_dispatch

  void hide_main_menu() {
    if(m_main_menu_switch.which.value()==SHOWN()) {
      m_main_menu_switch.which = HIDDEN();
      m_clear_color = m_params.m_scene_screen_color;
      if(m_params.m_auto_hide_scene) m_scene_switch.which = SHOWN();
      m_gui_sliders_switch.which = SHOWN(); //traverse scene sliders
    }
    if(!m_meta_had_been_shown) {
      m_meta_switch.which = SHOWN();
      m_meta_had_been_shown = true;
    }
  }
 
  void hide_meta_zone() {m_meta_switch.which = HIDDEN();}
  void set_meta_zone_had_been_shown() {m_meta_had_been_shown = true;}
  void set_meta_zone_had_not_been_shown() {m_meta_had_been_shown = false;}

  void show_camera_menu() {
    hide_main_menu();
    m_camenu_switch.which = SHOWN();
    set_camera_menu_labels();
  }

  void hide_camera_menu() {m_camenu_switch.which = HIDDEN();}

  void toggle_camera_menu() {
    if(m_camenu_switch.which==HIDDEN())
      show_camera_menu();
    else
      hide_camera_menu();
  }
  
  void set_camera_menu_labels() {
    set_arconf(m_camenu_shift_button,anim_shift_button_label());
    set_arconf(m_camenu_viewing_button,viewing_button_label());

    set_img_from_res_file(single_shoot_image_button_file(),m_camenu_sshoot_image_button.img.value());
    m_camenu_sshoot_image_button.img.touch();
    set_arconf(m_camenu_sshoot_text_button,single_shoot_button_label());

    set_img_from_res_file(rot_90_image_button_file(),m_camenu_90_image_button.img.value());
    m_camenu_90_image_button.img.touch();
    set_arconf(m_camenu_90_text_button,rot_90_button_label());

    set_arconf(m_camenu_focal_button,around_focal_button_label());
    set_arconf(m_camenu_plane_exam_button,plane_exam_button_label());
    set_use_gsto(m_use_gsto);
  }

  void toggle_plane_exam() {
    set_plane_viewer(plane_viewer()?false:true);
    set_camera_menu_labels();
  }

  void activate_meta_zone() {
    // some menu exists (mapped or not).
    if(m_main_menu_switch.which.value()==HIDDEN()) {
      // ask to map menu.
      show_main_menu();
      hide_camera_menu();
    } else { // some menu mapped.
      if(m_scene_camera) hide_main_menu();
    }
  }

  void hide_gui() { //used by rwc.
    hide_main_menu();
    hide_camera_menu();
    hide_meta_zone();
  }

  void toggle_light() {
    set_scene_light_on(m_params.m_light_on?false:true);
  }
  
  void toggle_gsto() {
    set_use_gsto(m_params.m_use_gsto?false:true);
  } 

  void show_progress() {m_progress_switch.which = SHOWN();}
  void hide_progress() {m_progress_switch.which = HIDDEN();}
  sg::progress& progress() {return m_progress;}

  void hide_sliders() {m_sliders_switch.which = HIDDEN();}
  void show_sliders() {m_sliders_switch.which = SHOWN();}
/*
  void toggle_sliders() {
    m_sliders_switch.which = m_sliders_switch.which==HIDDEN()?SHOWN():HIDDEN();
  }
*/

  slider& slider_1() {return m_slider_1;}
  slider& slider_2() {return m_slider_2;}
  slider& slider_3() {return m_slider_3;}
  slider& slider_4() {return m_slider_4;}

  void show_console() {m_console_switch.which = SHOWN();}
  void hide_console() {m_console_switch.which = HIDDEN();}
  //text_button& console() {return m_console;}

  void set_console_size(float a_width = 0.3F,float a_height = 0.05F,float a_scale = 1) {
    if(a_width!=m_params.m_console_width) {
      m_params.m_console_width = a_width;
      if(m_params.m_console_width<=0) m_params.m_console_width = 0.3F;
      set_console_layout();
    }
    if(a_height!=m_params.m_console_height) {
      m_params.m_console_height = a_height;
      if(m_params.m_console_height<=0) m_params.m_console_height = 0.05F;
      set_console_layout();
    }
    if(a_scale!=m_params.m_console_scale) {
      m_params.m_console_scale = a_scale;
      if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
      set_console_layout();
    }
  }

  void set_console_scale(float a_scale) {
    if(a_scale!=m_params.m_console_scale) {
      m_params.m_console_scale = a_scale;
      if(m_params.m_console_scale<=0) m_params.m_console_scale = 1;
      set_console_layout();
    }
  }

  void console_mag_two() {set_console_scale(m_params.m_console_scale*2);}

  ///////////////////////////////////////////////////////////////////
  /// popup : ///////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  void show_popup() {m_popup_switch.which = SHOWN();}
  void hide_popup() {m_popup_switch.which = HIDDEN();}
  separator& popup_sep() {return m_popup_sep;}
  //matrix& popup_matrix() {return m_popup_matrix;}
  sg::cbks& popup_cbks() {return m_popup_cbks;}
  const sg::cbks& popup_cbks() const {return m_popup_cbks;}

  void place_show_popup(int a_event_x,int a_event_y,float a_w,float a_h) {
    //a_w,a_h is the size of the popuped item.

    float one_wcw,one_wch; //wall : for one screen.

    float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);

    float all_wcw,all_wch; //wall : for all screens.
    get_gui_all_wcw_wch(all_wcw,all_wch);

    float x,y;
    screen_to_gui(a_event_x,a_event_y,x,y);

    // popup at top-left corner on x,y by taking
    // into account window limits.

    float xright = mn<float>(x+a_w,all_wcw*0.5f);
    //float xright = x+list.width;
    float ybot   = mx<float>(y-a_h,-all_wch*0.5f);

    float xpop = xright-a_w*0.5f;
    float ypop = ybot+a_h*0.5f;

    //compensate also the m_gui trans.
    m_popup_matrix.set_translate(xpop-tx,ypop-ty,0);

    show_popup();
  }
protected:
  template <class WIDGET>  //numeric, keyboard, colors
  void set_popup_size_pos(int a_ex,int a_ey,WIDGET& a_node) {
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}

    a_node.width = one_wcw*0.4F;
    a_node.height = one_wch*0.3f;

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }

  void set_popup_size_pos(int a_ex,int a_ey,sg::list& a_node) { //sg::file_chooser too.
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}
    float hbutton = one_wch*0.05f;

  //matrix m;
  //set_list_layout(a_node,one_wcw*0.5F,one_wch,hbutton,m);

  //list.visible_items = m_params.m_list_visible_items;
    a_node.visible_items = 5;
    a_node.text_common_height = true;
    a_node.width = one_wcw*0.5F;
    a_node.scroll_width = one_wcw*(device::small_screen()?0.15f:0.1f);
    a_node.height = a_node.visible_items*hbutton;
  //a_node.corner_radius = m_params.m_corner_radius;

  //a_node.text_hmargin_factor = 0.5f; //Apple
    s2layout_policy(m_params.m_list_item_layout,a_node.item_layout.value());
    a_node.corner_radius = m_params.m_corner_radius;

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }

  void set_popup_size_pos(int a_ex,int a_ey,sg::entries& a_node) {
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}
    float hbutton = one_wch*0.07f;

    matrix m;
    set_entries_layout(a_node,one_wcw*0.6F,one_wch,hbutton,m);

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }

  void set_popup_size_pos(int a_ex,int a_ey,sg::edvalop& a_node) {
    float one_wcw,one_wch; //wall : for one screen.
   {float tx,ty;
    float aspect;
    get_gui_wcw_wch(one_wcw,one_wch,tx,ty,aspect);}
    float hbutton = one_wch*0.05f;

    matrix m;
    set_edvalop_layout(a_node,one_wcw*0.6f,one_wch,hbutton,m);

    //set_style(a_node);
    a_node.width = one_wcw*0.4F;
    a_node.height = 6*hbutton;

    place_show_popup(a_ex,a_ey,a_node.width.value(),a_node.height.value());
  }
public:
  void popup_warn(int a_ex,int a_ey,const std::string& a_msg,bool a_warn = true) {
    hide_popup();

    list* _list = new list(ttf());

    if(a_warn) _list->back_color = m_params.m_gui_warn_back_color;
    else       _list->back_color = m_params.m_gui_warn_ok_color;
    _list->front_color = m_params.m_gui_warn_front_color;
    _list->border_color = m_params.m_gui_warn_border_color;

    _list->add(a_msg,new gv_cbk(*this,action_hide_popup));

    sg::separator& psep = popup_sep();
    psep.clear();
    psep.add(_list);

    set_popup_size_pos(a_ex,a_ey,*_list);
  }

  template <class WIDGET>
  void show_widget(WIDGET* a_node,bool a_popup,int a_ex,int a_ey) {
    if(a_popup) {
      sg::separator& psep = popup_sep();
      psep.clear();
      psep.add(a_node);
      set_popup_size_pos(a_ex,a_ey,*a_node);
    } else {
      push_list(a_node);
      show_main_menu();
    }
  }

  template <class WIDGET>
  void show_widget(const pos_data& a_data,WIDGET* a_node) {
    show_widget(a_node,a_data.m_popup,a_data.m_ex,a_data.m_ey);
  }

  void pop_warn(bool a_popup,int a_ex,int a_ey,const std::string& a_msg,bool a_warn = true) {
    if(a_popup) {
      popup_warn(a_ex,a_ey,a_msg,a_warn);
    } else {
      map_warn(a_msg,a_warn);
    }
  }

  void pop_warn(const pos_data& a_data,const std::string& a_msg,bool a_warn = true) {
    pop_warn(a_data.m_popup,a_data.m_ex,a_data.m_ey,a_msg,a_warn);
  }

  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////

  void map_warn(const std::string& a_msg,bool a_warn = true) {
    show_main_menu();
    list* _list = new list(m_ttf);
    set_style(*_list);
    if(a_warn) _list->back_color = m_params.m_gui_warn_back_color;
    else       _list->back_color = m_params.m_gui_warn_ok_color;
    _list->front_color = m_params.m_gui_warn_front_color;
    _list->border_color = m_params.m_gui_warn_border_color;
    _list->add(a_msg,new gv_cbk(*this,action_pop_list));
    m_uitems.push_back(_list);
    ask_to_rebuild_gui();
  }

  void do_escape() {activate_meta_zone();} 

  bool touch_down(int a_x,int a_y) {
    //a_x,a_y are signed because of wall. (0,0) is bottom left of window.

    if(!m_ww || !m_wh) return false;

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_down :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;       
    }

    unsigned int vp_ww = uint32(m_vr_mode?m_ww*0.5:m_ww);
    if(m_vr_mode) {if(a_x>=int(vp_ww)) a_x -= vp_ww;}

    down_event e(a_x,a_y);

    int old_scene_switch_which = m_scene_switch.which;
    int old_cursor_switch_which = m_cursor_switch.which;

    if(m_params.m_viewing) m_scene_switch.which = HIDDEN();
    m_cursor_switch.which = HIDDEN();

    event_action action(m_out,vp_ww,m_wh,e);
    m_sg.swap(0,1); //have m_gui traversed before m_scene_switch.
    m_sg.event(action);
    m_sg.swap(0,1); 

    m_scene_switch.which = old_scene_switch_which;
    m_cursor_switch.which = old_cursor_switch_which;

    return action.done();
  }

  bool touch_up(int a_x,int a_y) {
    //a_x,a_y are signed because of wall. (0,0) is bottom left of window.

    if(m_touch_in_motion) {
      m_touch_in_motion = false;

      if(m_motion_slider) {
        // We may have missed a touch up on the slider thumb.
        // We have to execute the ends callbacks anyway.
        add_work_cbks(m_motion_slider->ends(),true);    
        m_motion_slider = 0;
        return false;
      }
    }

    if(!m_ww || !m_wh) return false;

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_up :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;       
    }

    unsigned int vp_ww = uint32(m_vr_mode?m_ww*0.5:m_ww);
    if(m_vr_mode) {if(a_x>=int(vp_ww)) a_x -= vp_ww;}

    up_event e(a_x,a_y);

    int old_scene_switch_which = m_scene_switch.which;
    int old_cursor_switch_which = m_cursor_switch.which;

    if(m_params.m_viewing) m_scene_switch.which = HIDDEN(); //do not traverse scene.
    // But in viewing mode we would traverse m_scene before m_gui,
    // we have to swap m_scene_switch and m_gui->
    m_cursor_switch.which = HIDDEN(); //do not traverse cursor.

    event_action action(m_out,vp_ww,m_wh,e);
    m_sg.swap(0,1);
    m_sg.event(action);
    m_sg.swap(0,1);

    m_scene_switch.which = old_scene_switch_which;
    m_cursor_switch.which = old_cursor_switch_which;

    return action.done();
  }

  bool touch_move(int a_x,int a_y) { //could be negative in case of wall.
    unsigned int vp_ww = uint32(m_vr_mode?m_ww*0.5:m_ww);
    if(m_vr_mode) {if(a_x>=int(vp_ww)) a_x -= vp_ww;}

    if(!m_touch_in_motion) {
      m_touch_prev_x = a_x;
      m_touch_prev_y = a_y;
      m_touch_in_motion = true;
    }

    if(!m_ww||!m_wh) {
      m_touch_prev_x = a_x;
      m_touch_prev_y = a_y;
      return false;
    }

    if(m_verbose) {
      m_out << "inlib::sg::gui_viewer::touch_move :"
                    << " x " << a_x << " y " << a_y
                    << " ww " << m_ww << " wh " << m_wh
                    << std::endl;       
    }

    bool to_render = false;

    if(ui_visible()) {

      // for sliders in the gui.
      move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
      event_action action(m_out,vp_ww,m_wh,e);
      m_gui->event(action);
      to_render = false; //Android : "true" may induce double redraw.

    } else { //scene or sliders visible
    
      bool gui_hit = false; //for ArcheryTune mv animal whilst having sliders.

      if(sliders_visible()) {

        move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
        event_action action(m_out,vp_ww,m_wh,e);
        m_gui->event(action); //on m_sg ?
        hide_meta_zone(); //should have to_render = true ?
        to_render = false; //Android : "true" may induce double redraw.
        if(action.done()) {
          //to_render = true;
          gui_hit = true;
        }

      }

      if(!gui_hit) {
      if(m_params.m_viewing) {

        if(m_scene_camera && m_params.m_touch_move) {
          if(!m_params.m_plane_viewer && m_params.m_anim_around_focal) {

            float n2f = m_scene_camera->focal-m_scene_camera->znear;
            if(n2f) {
              float wnh = m_scene_camera->near_height();
              float aspect = float(vp_ww)/float(m_wh);
              float wnw = wnh*aspect;

              // x in wc in near plane :
              float wpx = wnw*float(m_touch_prev_x)/float(vp_ww);
              float wx  = wnw*float(a_x)/float(vp_ww);

              float apx = ::atan(wpx/n2f);
              float ax  = ::atan(wx/n2f);

              float da = ax-apx;

              if(m_scene_camera->type()==camera_perspective){
                da *= 10.0f; //cooking
              }

              m_scene_camera->rotate_around_y_at_focal(-da);

              hide_meta_zone();
              to_render = true;
            }
          } else {
            float wch;
            if(m_scene_camera->height_at_focal(wch)){
            //float wch = m_scene_camera->near_height();{

              float aspect = float(vp_ww)/float(m_wh);
              float wcw = wch*aspect;

              int dx = a_x-m_touch_prev_x;
              int dy = a_y-m_touch_prev_y;

              float wc_trans_x = wcw*float(dx)/float(vp_ww);
              float wc_trans_y = wch*float(dy)/float(m_wh);
              m_scene_camera->translate_along_side(-wc_trans_x);
              m_scene_camera->translate_along_up(-wc_trans_y);

              hide_meta_zone();
              to_render = true;
            }
          }
        }

      } else { //viewer is in picking mode.

        move_event e(a_x,a_y,m_touch_prev_x,m_touch_prev_y,true);
        event_action action(m_out,vp_ww,m_wh,e);
        m_scene_switch.event(action);
        if(action.done()) {
          //someone did something with this event (an image ?)
          to_render = true; //ioda::main::move_image_cbk uses console.
        }

      }}
    }

    m_touch_prev_x = a_x;
    m_touch_prev_y = a_y;

    return to_render;
  }

  void treat_mouse_motion(bool a_value) {m_treat_mouse_motion = a_value;}

  bool mouse_motion(unsigned int a_x,unsigned int a_y) {
    bool to_render = false;

    if(m_ww && m_wh && m_treat_mouse_motion) {

      move_event e(a_x,a_y,0,0,false);
      event_action action(m_out,m_ww,m_wh,e);
      m_scene_switch.event(action);
      if(action.done()) {
        //someone did something with this event (an image ?)
        to_render = true; //ioda::main::move_image_cbk uses console.
      }

    }

    return to_render;
  }

  /////////////////////////////////////
  /// gesture (mainly iOS) ////////////
  /////////////////////////////////////
  void start_gesture(unsigned int a_x,unsigned int a_y) {
    //keep separate for iPhone gestures.
    delete m_gesture_begin_camera;
    m_gesture_begin_camera = 0;
    if(m_scene_camera) {
      m_gesture_begin_camera = m_scene_camera->copy();
    }
    m_gesture_begin_x = a_x;
    m_gesture_begin_y = a_y;
  }

  base_camera* saved_cursor_and_camera(unsigned int& a_x,unsigned int& a_y) {
    a_x = m_gesture_begin_x;
    a_y = m_gesture_begin_y;
    if(!m_gesture_begin_camera) return 0;
    return safe_cast<node,base_camera>(*m_gesture_begin_camera);
  }

  void reset_camera_with_saved() {
    if(m_scene_camera && m_gesture_begin_camera) {

      ortho* oc = safe_cast<base_camera,ortho>(*m_scene_camera);
      perspective* pc =  safe_cast<base_camera,perspective>(*m_scene_camera);
      ortho* roc = safe_cast<node,ortho>(*m_gesture_begin_camera);
      perspective* rpc = safe_cast<node,perspective>(*m_gesture_begin_camera);

      if(oc && roc) {
        *oc = *roc;
      }
      if(pc && rpc) {
        *pc = *rpc;
      }
    }

    _set_params_camera();    
  }
  /////////////////////////////////////
  /////////////////////////////////////
  /////////////////////////////////////

public:
  base_camera* cursor_camera() const {return m_cursor_camera;}

  void set_cursor_position(float a_x,float a_y) {
    m_cursor_matrix.set_translate(a_x,a_y,0);
  } 
  void get_cursor_position(float& a_x,float& a_y) const {
    const mat4f& mtx = m_cursor_matrix.mtx.value();
    a_x = mtx[12];
    a_y = mtx[13];
  } 

public:
  //void clear_tmp_group() {m_tmp_group.clear();}

  //const group& tmp_group() const {return m_tmp_group;}
  //group& tmp_group() {return m_tmp_group;}

  template <class T>
  void add_in_tmp_group(const std::string& a_name,T* a_obj) {
    m_tmp_group.add(new holder<T>(a_obj,a_name));
  }

  template <class T>
  T* find_in_tmp_group(const std::string& a_name) {
    return find_holder<T>(m_tmp_group.children(),a_name);
  }

  template <class T>
  T* find_first_in_tmp_group() {
    return find_first_holder<T>(m_tmp_group.children());
  }

  template <class T>
  void remove_in_tmp_group(const std::string& a_name) {
    remove_holders<T>(m_tmp_group.children(),a_name);
  }

protected:
  static void set_button_style(const gui_params& a_params,
                               text_button& a_node) {
    a_node.back_area::color = a_params.m_gui_back_color;
    a_node.back_area::border_color = a_params.m_gui_border_color;
    a_node.color = a_params.m_gui_front_color;
    a_node.arm_color = a_params.m_gui_arm_color;
    a_node.hmargin_factor = 0.5f; //Apple seems to have that.
    a_node.font = a_params.m_gui_font;
    a_node.font_modeling = a_params.m_gui_font_modeling;
  }
  static void set_image_button_style(const gui_params& a_params,
                                     image_button& a_node) {
    a_node.back_area::color = a_params.m_gui_back_color;
    a_node.back_area::border_color = a_params.m_gui_border_color;
    a_node.color = a_params.m_gui_back_color;
    a_node.arm_color = a_params.m_gui_arm_color;
    //a_node.hmargin_factor = 0.8f;
    a_node.hmargin_factor = 0.6f;
  }
  static void set_arrow_button_style(const gui_params& a_params,
                                     arrow_button& a_node) {
    a_node.back_area::color = a_params.m_gui_back_color;
    a_node.back_area::border_color = a_params.m_gui_border_color;
    a_node.color = a_params.m_gui_front_color;
    a_node.arm_color = a_params.m_gui_arm_color;
  }

  //static //not static because of set_img_from_file
  void create_main_button(std::ostream&,
                          const std::string& /*a_res_dir*/,
                          const gui_params& a_params,
                          separator& a_parent,
                          float a_wcw,float a_wch,float a_wb,float a_hb,
                          float a_roffset,
                          unsigned int a_col,unsigned int a_row,
                          const std::string& a_label,
                          const std::string& a_img_label,
                          const std::string& a_img,
                          bcbk* a_cbk) { //take ownerhship.
    //a_col=[0,a_cols-1] 0=left
    //a_row=[0,a_rows-1] 0=bottom
    //a_roffset : for Wt : to see right border of buttons at right.
 
    //float wbutton = a_wcw/float(a_cols);
    //float hbutton = a_wch/float(a_rows);
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    if(a_img.size()&&a_params.m_image_buttons) {
      image_text_button* b = new image_text_button(m_ttf);
      b->width = wbutton;
      b->height = hbutton;

      set_image_button_style(a_params,*b);
      set_img_from_res_file(a_img,b->img.value());
      b->img.touch();

      if(a_img_label.size()) {
        b->text().strings.clear();
        b->text().strings.add(a_img_label);
        b->text().font = a_params.m_gui_font;
        b->text().font_modeling = a_params.m_gui_font_modeling;
        b->text().color = a_params.m_gui_front_color;
      }
      s2layout_policy(m_params.m_list_item_layout,b->layout.value());
      b->corner_radius = a_params.m_corner_radius;

      b->add_callback(a_cbk);
      sep->add(b);

    } else {
      text_button* b = new text_button(m_ttf);
      b->width = wbutton;
      b->height = hbutton;

      set_button_style(a_params,*b);
      set_arconf(*b,a_label);

      b->corner_radius = a_params.m_corner_radius;

      b->add_callback(a_cbk);
      sep->add(b);
    }
  }

  //static //not static because of set_img_from_file
  void create_main_button(std::ostream&,
                          const std::string& /*a_res_dir*/,
                          const gui_params& a_params,
                          separator& a_parent,
                          float a_wcw,float a_wch,float a_wb,float a_hb,
                          float a_roffset,
                          unsigned int a_col,unsigned int a_row,
                          image_button& a_img_button,
                          text_button& a_button,
                          const std::string& a_label,
                          const std::string& a_img,
                          bcbk* a_cbk) { //take ownerhship.
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    if(a_params.m_image_buttons) {
      a_img_button.width = wbutton;
      a_img_button.height = hbutton;

      set_image_button_style(a_params,a_img_button);
      set_img_from_res_file(a_img,a_img_button.img.value());
      a_img_button.img.touch();

      a_img_button.corner_radius = a_params.m_corner_radius;

      a_img_button.clear_cbks();
      a_img_button.add_callback(a_cbk);
      sep->add(new noderef(a_img_button));

    } else {
      a_button.width = wbutton;
      a_button.height = hbutton;

      set_button_style(a_params,a_button);
      set_arconf(a_button,a_label);

      a_button.corner_radius = a_params.m_corner_radius;

      a_button.clear_cbks();
      a_button.add_callback(a_cbk);
      sep->add(new noderef(a_button));
    }
  }

  static void create_main_button(
                          const gui_params& a_params,
                          separator& a_parent,
                          float a_wcw,float a_wch,float a_wb,float a_hb,
                          float a_roffset,
                          unsigned int a_col,unsigned int a_row,
                          const std::string& a_label,
                          text_button& a_button,
                          bcbk* a_cbk) { //take ownerhship.
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    a_button.width = wbutton;
    a_button.height = hbutton;

    set_button_style(a_params,a_button);
    set_arconf(a_params,a_button,a_label);

    a_button.corner_radius = a_params.m_corner_radius;

    a_button.clear_cbks();
    a_button.add_callback(a_cbk);

    sep->add(new noderef(a_button));
  }

  static void create_arrow(const gui_params& a_params,
                           separator& a_parent,
                           float a_wcw,float a_wch,float a_wb,float a_hb,
                           float a_roffset,
                           unsigned int a_col,unsigned int a_row,
                           arrow_type a_type,
                           bcbk* a_cbk) { //take ownerhship.
    float wbutton = a_wb;
    float hbutton = a_hb;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;

    float x = -a_wcw*0.5F+wbutton*0.5f; //at left.
    x += a_col*wbutton;
    x -= a_wcw*a_roffset;

    float y = -a_wch*0.5F+hbutton*0.5f; //at bottom.
    y += a_row*hbutton;

    m->set_translate(x,y,0);
    sep->add(m);

    arrow_button* b = new arrow_button;
    b->width = wbutton;
    b->height = hbutton;
    b->orientation = a_type;
    set_arrow_button_style(a_params,*b);

    b->corner_radius = a_params.m_corner_radius;

    b->add_callback(a_cbk);

    sep->add(b);
  }

  static void create_meta_zone(const gui_params& a_params,
                               const base_freetype& a_ttf,
                               separator& a_parent,
                               _switch& a_meta_switch,
                               float a_wcw,float a_wch,float a_hzone,
                               bcbk* a_cbk) { //take ownerhship.
    int old_meta_switch_which = a_meta_switch.which;

    separator* sep = new separator;
    a_parent.add(sep);

    matrix* m = new matrix;
    float wbutton = a_wcw;
    float x = 0;
    float y = -a_wch*0.5F+a_hzone*0.5f;
    m->set_translate(x,y,-0.1f);
    sep->add(m);

    a_meta_switch.clear();
    sep->add(new noderef(a_meta_switch));

   {text_button* b = new text_button(a_ttf);
    set_arconf(a_params,*b,"scene to menu area (shown once)");
    set_button_style(a_params,*b);
    b->back_area::color = colorf(0.7f,0.9f,1,0.2f);
    //b->width = wbutton*(1-2*0.3f);
    b->width = wbutton;
    b->height = a_hzone;
    b->add_callback(a_cbk->copy());
    a_meta_switch.add(b);}

   {ghost* b = new ghost;
    b->width = wbutton;
    b->height = a_hzone;
    b->add_callback(a_cbk);
    a_meta_switch.add(b);}

    a_meta_switch.which = old_meta_switch_which;
  }

public:
  bool set_img(image_button& a_button,const std::string& a_file) {
    bool status = set_img_from_res_file(a_file,a_button.img.value());
    a_button.img.touch();
    return status;
  }

public:
  float gui_camera_height() const {return 2;}

  void create_gui() { //public to handle DOCUMENT at startup.
    //NOTE : there is no callback setup here. There are done
    //       in sub virtual methods.

    //m_out << "inlib::sg::gui_viewer::create_gui : " << std::endl;

    int old_menu_switch_which = m_main_menu_switch.which;
    int old_camenu_switch_which = m_camenu_switch.which;
    int old_gui_sliders_switch_which = m_gui_sliders_switch.which;
    int old_sliders_switch_which = m_sliders_switch.which;
    int old_progress_switch_which = m_progress_switch.which;
    //int old_meta_switch_which = m_meta_switch.which;
    int old_console_switch_which = m_console_switch.which;
    int old_popup_switch_which = m_popup_switch.which;

    m_gui->clear();

   {depth_test* node = new depth_test;
    node->on = false;
    m_gui->add(node);}

    bool old_param_cam_tiled = m_params.m_cam_tiled;
    //wall screen app : enforce gui in one screen only.
    m_params.m_cam_tiled = true;

    // NOTE : wall : in this case camera height is mapped
    //               on the whole "wall inside external borders" height.

    float cam_height = gui_camera_height();
    base_camera* camera = create_camera(camera_ortho,cam_height,0.1f);
    camera->position.value().set_value(0,0,2);
    camera->focal = 2;
    m_gui->add(camera);

    m_params.m_cam_tiled = old_param_cam_tiled;

    float wcw,wch,aspect;

   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);
    matrix* m = new matrix;
    m->set_translate(tx,ty,0);
    m_gui->add(m);}

    float hbutton = wch/float(10);

    float right_offset = 0.001f; //Wt : to see the right border of buttons.

    ///////////////////////////////////////////////////////////////////////
    /// sliders ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    // sliders are in front of the scene but behind all UI things.

    m_gui_sliders_switch.clear();
    m_gui->add(new noderef(m_gui_sliders_switch));

   {m_sliders_switch.clear();
    m_gui_sliders_switch.add(new noderef(m_sliders_switch));
    m_gui_sliders_switch.add(new separator());
    m_gui_sliders_switch.which = old_gui_sliders_switch_which;

    separator* sliders_sep = new separator;
    m_sliders_switch.add(sliders_sep);
    m_sliders_switch.add(new separator());
    m_sliders_switch.which = old_sliders_switch_which;

    create_sliders(aspect,wcw,wch,*sliders_sep);}

    ///////////////////////////////////////////////////////////////////////
    /// main menu /////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_main_menu_switch.clear();
    m_gui->add(new noderef(m_main_menu_switch));

    m_full_sep.clear();

    m_main_menu_switch.add(new noderef(m_full_sep));
    m_main_menu_switch.add(new separator());
    m_main_menu_switch.which = old_menu_switch_which;
    m_clear_color = m_main_menu_switch.which.value()==SHOWN()?
      m_params.m_gui_screen_color:m_params.m_scene_screen_color;

    float wbutton = wcw/float(3);

    create_control_items(wcw,wch,wbutton,hbutton,right_offset);
  
   {separator* sep = new separator;
    m_full_sep.add(sep);

    matrix* m = new matrix;
    sep->add(m);

    node* _node = current_list();
    if(_node) {
      if(list* _list = safe_cast<node,list>(*_node)) {
        set_list_layout(*_list,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(text* _text = safe_cast<node,text>(*_node)) {
        set_text_layout(*_text,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(scroll_text* _stext = safe_cast<node,scroll_text>(*_node)) {
        set_scroll_text_layout(*_stext,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(scroll_infos* _sinfos = safe_cast<node,scroll_infos>(*_node)) {
        set_scroll_infos_layout(*_sinfos,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(numeric* _numeric = safe_cast<node,numeric>(*_node)){
        _numeric->width = wcw*0.5F;
        _numeric->height = wch*0.5F;
        _numeric->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(edvalop* _edvalop = safe_cast<node,edvalop>(*_node)){
        set_edvalop_layout(*_edvalop,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(colors* _colors = safe_cast<node,colors>(*_node)) {
        _colors->width = wcw*0.8F;
        _colors->height = wch*0.5F;
        _colors->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(/* button_grid<simple_button>* cnode = */
                  safe_cast<node, button_grid<simple_button> >(*_node)) {
        // do not enforce a size. If not see rwc_gui.
        //cnode->width = wcw*0.8F;
        //cnode->height = wch*0.5F;
        sep->add(new noderef(*_node));

      } else if(keyboard* _kb = safe_cast<node,keyboard>(*_node)){
        _kb->width = wcw*0.98F;
        _kb->height = wch*0.5F;
        _kb->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(entry* _entry = safe_cast<node,entry>(*_node)) {
        _entry->width = wcw*0.5F;
        _entry->height = hbutton;
        _entry->text_hmargin_factor = 0.5f; //Apple
        sep->add(new noderef(*_node));

      } else if(entries* _entries = safe_cast<node,entries>(*_node)) {
        set_entries_layout(*_entries,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      } else if(slider* _slider = safe_cast<node,slider>(*_node)) {
        _slider->width = wcw*0.5F;
        _slider->height = wch*0.05F;
        sep->add(new noderef(*_node));

      } else if(back_area* _ba = safe_cast<node,back_area>(*_node)) {
        set_back_area_layout(*_ba,wcw,wch,hbutton,*m);
        sep->add(new noderef(*_node));

      }
    }}

    } //end central menu.

    ///////////////////////////////////////////////////////////////////////
    /// camera menu ///////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_camenu_switch.clear();
    m_gui->add(new noderef(m_camenu_switch));

    m_camenu_switch.add(new noderef(m_camenu_sep));
    m_camenu_switch.add(new separator());
    m_camenu_switch.which = old_camenu_switch_which;

    unsigned int nbutton = device::small_screen()?15:20;
    float warrow = wcw/float(nbutton);
    float harrow = warrow;

    m_camenu_sep.clear();

    create_camenu_items(nbutton,wcw,wch,warrow,harrow);

    } //end camenu

    ///////////////////////////////////////////////////////////////////////
    /// console ///////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_console_switch.clear();
    m_gui->add(new noderef(m_console_switch));

    separator* console_sep = new separator;
    m_console_switch.add(console_sep);
    m_console_switch.add(new separator());
    m_console_switch.which = old_console_switch_which;

    console_sep->add(new noderef(m_console_matrix));
    console_sep->add(new noderef(m_console));

    set_button_style(m_params,m_console);
    _set_console_layout(wcw,wch);

    } //end console

    ///////////////////////////////////////////////////////////////////////
    /// progress //////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
   {m_progress_switch.clear();
    m_gui->add(new noderef(m_progress_switch));

    separator* progress_sep = new separator;
    m_progress_switch.add(progress_sep);
    m_progress_switch.add(new separator());
    m_progress_switch.which = old_progress_switch_which;

    float h = wch*0.05f;
    float w = wcw*0.8f;

    m_progress.width = w;
    m_progress.height = h;
    m_progress.color = m_params.m_gui_arm_color;
  //m_progress.corner_radius = m_params.m_corner_radius;
    progress_sep->add(new noderef(m_progress));
    }

    ///////////////////////////////////////////////////////////////////////
    /// popup /////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

   {m_popup_switch.clear();
    m_gui->add(new noderef(m_popup_switch));

    separator* _popup_sep = new separator;
    m_popup_switch.add(_popup_sep);
    m_popup_switch.add(new separator());
    m_popup_switch.which = old_popup_switch_which;

    //m_popup_matrix.set_identity();
    _popup_sep->add(new noderef(m_popup_matrix));
    _popup_sep->add(new noderef(m_popup_sep));

    } //end popup

    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    create_meta_zone(wcw,wch,hbutton);

  }

protected:
  // virtual gui methods containing callbacks :
  // For example redefined for the wall data client remote control gui.
  virtual void create_meta_zone(float a_wcw,float a_wch,float a_hzone) {
    create_meta_zone(m_params,m_ttf,*m_gui,m_meta_switch,
                     a_wcw,a_wch,a_hzone,
                     new gv_cbk(*this,action_activate_meta_zone));
  }

  virtual void create_control_items(float a_wcw,float a_wch,
                                    float a_wb,float a_hb,float a_roffset) {
    create_main_button(m_out,m_res_dir,m_params,
                       m_full_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,0,"home","home","go_home_large.jpg",
                       new gv_cbk(*this,action_push_home));

    if(params_button_visible.value()) { 
      create_main_button(m_out,m_res_dir,m_params,
                         m_full_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         0,1,"params","params","system_config_boot.jpg",
                         new gv_cbk(*this,action_params_show));
    }
  
    create_main_button(m_out,m_res_dir,m_params,
                       m_full_sep,a_wcw,a_wch,a_wb,a_hb,a_roffset,
                       2,0,"back","back","turn_around.jpg",
                       new gv_cbk(*this,action_push_back_item));

    if(camera_button_visible.value()) { 
      create_main_button(m_out,m_res_dir,m_params,
                         m_full_sep,a_wcw,a_wch,a_wb,a_hb,a_roffset,
                         2,1,"camera","camera","movie_camera.jpg",
                         new gv_cbk(*this,action_show_camera_menu));
    }
  }

  virtual void create_camenu_items(unsigned int a_nb,float a_wcw,float a_wch,float a_wb,float a_hb) {

    ///////////////////////////////////////////////////////////////////////
    /// camenu right area /////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////
    // create four arrows :
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-2,2,arrow_up,
                 new gv_cbk(*this,action_up));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-2,0,arrow_down,
                 new gv_cbk(*this,action_down));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-3,1,arrow_left,
                 new gv_cbk(*this,action_left));
    create_arrow(m_params,
                 m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                 a_nb-1,1,arrow_right,
                 new gv_cbk(*this,action_right));

    //inside "shift" button :
    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-2,1,anim_shift_button_label(),
                       m_camenu_shift_button,
                       new gv_cbk(*this,action_toggle_param_anim_shift));

    //outside top-left "single shoot" button :
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-3,2,
                       m_camenu_sshoot_image_button,
                       m_camenu_sshoot_text_button,
                       single_shoot_button_label(),
                       single_shoot_image_button_file(),
                       new gv_cbk(*this,action_toggle_param_single_shoot));

    //outside bottom-right hide button :
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-1,0,"hide","","close.jpg",
                       new gv_cbk(*this,action_hide_camera_menu));

    //outside top-right reset camera button :
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-1,2,"reset","","edit_undo.jpg",
                       new gv_cbk(*this,action_reset_camera));

    //outside bottom-left "90" button :
    if(camenu_90_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-3,0,
                         m_camenu_90_image_button,
                         m_camenu_90_text_button,
                         rot_90_button_label(),
                         rot_90_image_button_file(),
                         new gv_cbk(*this,action_toggle_param_90));
    }

    if(camenu_edit_visible.value()) {
      //outside top-left "edit" button :
      create_main_button(m_out,m_res_dir,m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-4,2,"edit","","edit.jpg",
                         new gv_cbk(*this,action_cam_choose_type));
    }

    if(camenu_focal_visible.value()) {
      //"aroud focal" button under the edit one :
      create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-4,1,around_focal_button_label(),
                       m_camenu_focal_button,
                       new gv_cbk(*this,action_toggle_param_anim_around_focal));
    }
  
    if(camenu_viewing_visible.value()) {
      // viewing/picking mode button under the focal one :
      create_main_button(m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         a_nb-4,0,viewing_button_label(),
                         m_camenu_viewing_button,
                         new gv_cbk(*this,action_toggle_param_viewing));
    }

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,2,"mv","","",
                       new gv_cbk(*this,action_cam_choose_anim));

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,1,"EA","","object_rotate_left.jpg",
                       new gv_cbk(*this,action_enable_anim));

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,0,"DA","","stop_object_rotate_left.jpg",
                       new gv_cbk(*this,action_disable_anim));

/*
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       a_nb-5,1,"P/O","","",
                       new gv_cbk(*this,action_swap_camera_kind));
*/
    ///////////////////////////////////////////////////////////////////////
    /// camenu left area //////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////

/*
    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,0,"clear","","edit_clear.jpg",
                       new gv_cbk(*this,action_clear_static_and_dynamic_scene)); //does not compile.
*/

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,0,"W/B","","",
                       new gv_cbk(*this,action_swap_scene_clear_color));

    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       0,1,plane_exam_button_label(),
                       m_camenu_plane_exam_button,
                       new gv_cbk(*this,action_toggle_plane_exam));

    if(camenu_view_all_visible.value()) {
      create_main_button(m_out,m_res_dir,m_params,
                         m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                         0,2,"<)","","",
                         new gv_cbk(*this,action_adapt_camera_to_scene));
   }

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,0,"N","","",
                       new gv_cbk(*this,action_count_points));

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,1,"^","","",
                       new gv_cbk(*this,action_toggle_light));

    create_main_button(m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,2,"gsto",
                       m_camenu_gsto_button,
                       new gv_cbk(*this,action_toggle_gsto));
    set_use_gsto(m_use_gsto); //update back color.

    create_main_button(m_out,m_res_dir,m_params,
                       m_camenu_sep,a_wcw,a_wch,a_wb,a_hb,0,
                       1,3,"png","","",
                       new gv_cbk(*this,action_export_png));

  }
public:
  //virtual bool insh_dispatch(const std::string&,const std::vector<std::string>&) {return false;} //see below.
protected:
  void _set_console_layout(float a_wcw,float a_wch) {
    float hconsole = a_wch*m_params.m_console_height*m_params.m_console_scale;
    float wconsole = a_wcw*m_params.m_console_width*m_params.m_console_scale;

    float x = -a_wcw*0.5F+wconsole*0.5F; //right.
    float y = a_wch*0.5F-hconsole*0.5f; //top
    m_console_matrix.set_translate(x,y,0);

    m_console.width = wconsole;
    m_console.height = hconsole;
  }
public:
  void set_console_layout() {
    float wcw,wch;
   {float tx,ty,aspect;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}
    _set_console_layout(wcw,wch);
  }
protected:

  void set_sliders_layout(float a_wcw,float a_wch,float a_aspect) {
    float hslider = a_wch*0.025f; // desktops.
    if(device::small_screen()) {
      if(a_aspect>1) {
        hslider *= 3;
      } else {
        hslider *= 2;
      }
    }

    float whide = hslider;
    float hhide = hslider;
    float whand = 4*whide; //for Archery vertical slider.

    // slider 1 :
   {float wslider,x,y;
    if((m_params.m_sliders_pos==gui_params::s_sliders_2b())    ||
       (m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) ){
      wslider = (a_wcw-whide)*0.5f;
      x = -a_wcw*0.5f+wslider*0.5f; //left
      y = -a_wch*0.5F+hslider*0.5f; //bottom
    } else if(m_params.m_sliders_pos==gui_params::s_sliders_bl()) {
      wslider = a_wcw-whide;
      x = -a_wcw*0.5f+wslider*0.5f; //left
      y = -a_wch*0.5F+hslider*0.5f; //bottom
    } else {
      wslider = 0; //not visible.
      x = 0;
      y = 0;
    }
    m_slider_1_matrix.set_translate(x,y,0);
    m_slider_1.width = wslider;
    m_slider_1.height = hslider;
    m_slider_1.size = whand;}

    // slider 2 :
   {float wslider,x,y;
    if((m_params.m_sliders_pos==gui_params::s_sliders_2b())    ||
       (m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) ){
      wslider = (a_wcw-whide)*0.5f;
      x = -a_wcw*0.5f+wslider*0.5f+wslider; //left+wslider
      y = -a_wch*0.5F+hslider*0.5f;         //bottom
    } else {
      wslider = 0; //not visible.
      x = 0;
      y = 0;
    }
    m_slider_2_matrix.set_translate(x,y,0);
    m_slider_2.width = wslider;
    m_slider_2.height = hslider;
    m_slider_2.size = whand;}

    // slider 3 :
   {float wslider,x,y;
    if(m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) {
      wslider = (a_wch-hhide)*0.5f;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f-wslider;
      m_slider_3_matrix.set_translate(x,y,0);
      m_slider_3_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else if((m_params.m_sliders_pos==gui_params::s_sliders_bl())||
              (m_params.m_sliders_pos==gui_params::s_sliders_l()) ){
      wslider = a_wch-hhide;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f;
      m_slider_3_matrix.set_translate(x,y,0);
      m_slider_3_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else {
      wslider = 0; //not visible
      x = 0;
      y = 0;
      m_slider_3_matrix.set_translate(x,y,0);
    }
    m_slider_3.width = wslider;
    m_slider_3.height = hslider;
    m_slider_3.size = whand;}

    // slider 4 :
   {float wslider,x,y;
    if(m_params.m_sliders_pos==gui_params::s_sliders_2b_2l()) {
      wslider = (a_wch-hhide)*0.5f;
      x = a_wcw*0.5F-hslider*0.5F; //at right
      y = a_wch*0.5F-wslider*0.5f;
      m_slider_4_matrix.set_translate(x,y,0);
      m_slider_4_matrix.mul_rotate(0,0,1,fhalf_pi()); //applied first
    } else {
      wslider = 0; //not visible
      x = 0;
      y = 0;
      m_slider_4_matrix.set_translate(x,y,0);
    }
    m_slider_4.width = wslider;
    m_slider_4.height = hslider;
    m_slider_4.size = whand;}

    // hide button :
   {float x = a_wcw*0.5F-whide*0.5F; //at right. //2b,2b_2v
    float y = -a_wch*0.5F+hhide*0.5f; //bottom
    m_hide_sliders_matrix.set_translate(x,y,0);}

    if(m_hide_sliders_sep.size()<=0) {
      //m_out << "set_sliders_layout : warning : m_hide_slides_sep empty." << std::endl;
    } else {
      back_area* ba = safe_cast<node,back_area>(*m_hide_sliders_sep[1]);
      if(ba) {
        ba->width = whide;
        ba->height = hhide;
      }
    }
  }
public:
  void set_sliders_layout() {
    float wcw,wch,aspect;
   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}
    set_sliders_layout(wcw,wch,aspect);
  }
  void set_sliders_pos(const std::string& a_v) {
    if(m_params.m_sliders_pos==a_v) return;
    m_params.m_sliders_pos = a_v;
    set_sliders_layout();
  }
protected:
  void create_sliders(float a_aspect,float a_wcw,float a_wch,separator& a_sliders_sep) {
    // slider 1 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_1_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_1));}

    // slider 2 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_2_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_2));}

    // slider 3 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_3_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_3));}

    // slider 4 :
   {separator* sep = new separator;
    a_sliders_sep.add(sep);
    sep->add(new noderef(m_slider_4_matrix));
    //we don't set value and cbks here.
    sep->add(new noderef(m_slider_4));}

    // hide button :
   {m_hide_sliders_sep.clear();
    a_sliders_sep.add(new noderef(m_hide_sliders_sep));

    m_hide_sliders_sep.add(new noderef(m_hide_sliders_matrix)); //0

    if(m_params.m_image_buttons) {
      image_button* b = new image_button;
      set_image_button_style(m_params,*b);
      set_img(*b,"close.jpg");
      b->add_callback
        (new fundata_cbk<gui_viewer,_switch,pos_data>(*this,m_sliders_switch,action_hide,pos_data(false,0,0)));
      m_hide_sliders_sep.add(b); //1
    } else {
      text_button* b = new text_button(m_ttf);
      set_button_style(m_params,*b);
      set_arconf(*b,"H");
      b->add_callback
        (new fundata_cbk<gui_viewer,_switch,pos_data>(*this,m_sliders_switch,action_hide,pos_data(false,0,0)));
      m_hide_sliders_sep.add(b); //1
    }}

    set_sliders_layout(a_wcw,a_wch,a_aspect);

    set_slider_style(m_slider_1);
    set_slider_style(m_slider_2);
    set_slider_style(m_slider_3);
    set_slider_style(m_slider_4);
  }

protected:
  void _set_params_camera() {

    if(!m_scene_camera) {
      m_params.m_camera_type.clear();

    } else if(safe_cast<base_camera,ortho>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_ortho();
    } else if(safe_cast<base_camera,lrbt>(*m_scene_camera)) { 
      m_params.m_camera_type = s_camera_ortho();

    } else if(safe_cast<base_camera,perspective>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_perspective();
    } else if(safe_cast<base_camera,frustum>(*m_scene_camera)) {
      m_params.m_camera_type = s_camera_perspective();

    } else {
      m_params.m_camera_type.clear();
    }

    // for rwc :
    // one wall screen apps send the m_cam_<xxx> params to the rwc.
    // See wall/SDL_dispatch.
    if(!m_scene_camera) {
      m_params.m_cam_x = 0;
      m_params.m_cam_y = 0;
      m_params.m_cam_z = 0;
      m_params.m_cam_near = 0;
      m_params.m_cam_far = 0;
      m_params.m_cam_focal = 0;
      m_params.m_cam_dx = 0;
      m_params.m_cam_da = 0;
      m_params.m_cam_ds = 0;
    } else {
      m_params.m_cam_x = m_scene_camera->position.value().x();
      m_params.m_cam_y = m_scene_camera->position.value().y();
      m_params.m_cam_z = m_scene_camera->position.value().z();
      m_params.m_cam_near = m_scene_camera->znear;
      m_params.m_cam_far = m_scene_camera->zfar;
      m_params.m_cam_focal = m_scene_camera->focal;
      m_params.m_cam_dx = m_scene_camera->dx;
      m_params.m_cam_da = m_scene_camera->da;
      m_params.m_cam_ds = m_scene_camera->ds;
    }
    m_params.m_cam_zof = 1;
  }
public:
  void reset_camera() {
    if(m_scene_camera && m_reset_camera) {

      ortho* oc = safe_cast<base_camera,ortho>(*m_scene_camera);
      perspective* pc = safe_cast<base_camera,perspective>(*m_scene_camera);
      lrbt* lc = safe_cast<base_camera,lrbt>(*m_scene_camera);
      frustum* fc = safe_cast<base_camera,frustum>(*m_scene_camera);

      ortho* roc = safe_cast<node,ortho>(*m_reset_camera);
      perspective* rpc = safe_cast<node,perspective>(*m_reset_camera);
      lrbt* rlc = safe_cast<node,lrbt>(*m_reset_camera);
      frustum* rfc = safe_cast<node,frustum>(*m_reset_camera);

      if(oc && roc) {
        *oc = *roc;
      }
      if(pc && rpc) {
        *pc = *rpc;
      }
      if(lc && rlc) {
        *lc = *rlc;
      }
      if(fc && rfc) {
        *fc = *rfc;
      }
    }

    _set_params_camera();    
  }

  bool adapt_camera_to_scene() {return adapt_camera(scene());}

  bool adapt_camera(node& a_node) {
    base_camera* cam = scene_camera();
    if(!cam) return false;

    bbox_action _action(m_out);
    a_node.bbox(_action);
    if(!_action.end()) return false;
    vec3f c;
    if(!_action.box().center(c)) return false;
    float dx,dy,dz;
    if(!_action.box().get_cube_size(dx,dy,dz)) return false;    

    //::printf("debug : gui_viewer::adapt_camera : center = %g %g %g, size = %g %g %g\n",c.x(),c.y(),c.z(),dx,dy,dz);

    group* grp = find_container<group>(m_out,*m_scene,*cam,false);
    if(!grp) return false;
       
    float radius = ::sqrtf(dx*dx+dy*dy+dz*dz);

    float z = radius*2; // z = 2*dz is not ok for bbox thin in z but large in x,y.
    float znear = 0.01f*z;
    float ortho_cam_height = 0;
    if(dy>=dx) {
      ortho_cam_height = dy*1.2f;
    } else {
      float cam_width = dx*1.2f;
      float aspect = float(m_ww)/float(m_wh);
      ortho_cam_height = cam_width/aspect;
    }

    base_camera* new_cam = 0;

    if( safe_cast<base_camera,ortho>(*cam) || safe_cast<base_camera,lrbt>(*cam)  ){ 

      new_cam = create_camera(camera_ortho,ortho_cam_height,znear);

    } else if(safe_cast<base_camera,perspective>(*cam) || safe_cast<base_camera,frustum>(*cam) ){
    
      float angle = 2*fatan((0.5f*ortho_cam_height)/z);

      float near_height = 2*znear*ftan(angle*0.5f);

      new_cam = create_camera(camera_perspective,near_height,znear);

    } else {
      m_out << "inlib::sg::gui_viewer::adapt_camera :"
                    << " camera not ortho and not perspective."
                    << std::endl;
    }

    if(!new_cam) return false;

    new_cam->zfar = 100*z;
    new_cam->position = vec3f(0,0,z);
    new_cam->dx = z*0.003f;
    new_cam->focal = z;

    new_cam->position.value() += c;

    if(!grp->replace(cam,new_cam,true)) {
      delete new_cam;
      return false;
    }

    set_scene_camera(new_cam);

    return true;
  }

  bool cam_anim_is_running() const {
    if(!m_scene_camera) return false;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    return anim?true:false;
  }

  void stop_cam_anim() {
    if(!m_scene_camera) return;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    if(!anim) return; //done

    //restore a not anim camera :
    search_action sa(m_out);
    const path_t& _path = find_path(sa,*m_scene,*m_scene_camera,false);
    if(_path.empty()) {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " path not found for current camera."
                    << std::endl;       
      return;
    }
    group* grp = container<group>(_path);
    if(!grp) {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " camera group not found."
                    << std::endl;       
      return;
    }

    base_camera* new_cam = 0;
    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      new_cam = new perspective(*pc);
    } else if(frustum* fc = safe_cast<node,frustum>(*m_scene_camera)){
      new_cam = new frustum(*fc);
    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      new_cam = new ortho(*oc);
    } else if(lrbt* lc = safe_cast<node,lrbt>(*m_scene_camera)){
      new_cam = new lrbt(*lc);

    } else {
      m_out << "inlib::sg::gui_viewer::stop_cam_anim :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return;
    }

    grp->replace(m_scene_camera,new_cam,true); // it deletes m_scene_camera.
    set_scene_camera(new_cam,false); //WARNING : false
  }

  void start_cam_anim(anim_what a_anim,bool a_shift,unsigned int a_cycle) {
    int move;
    if(!anim2motion(a_anim,a_shift,move)) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " unknown anim code " << a_anim
                    << std::endl;       
      return;
    }
    start_cam_move(move,a_cycle);
  }

  void start_cam_move(int a_move,unsigned int a_cycle) {
    if(!m_scene_camera) return;
    base_anim* anim = safe_cast<node,base_anim>(*m_scene_camera);
    if(anim) return; //done

    search_action sa(m_out);
    const path_t& _path = find_path(sa,*m_scene,*m_scene_camera,false);
    if(_path.empty()) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " path not found for current camera."
                    << std::endl;       
      return;
    }

    group* grp = container<group>(_path);
    if(!grp) {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " camera group not found."
                    << std::endl;       
      return;
    }

    atime _now(0,0);
    if(!get_time_now(_now)) {}

    base_camera* new_cam = 0;
    if(perspective* pc = safe_cast<node,perspective>(*m_scene_camera)){
      new_cam = new camera_anim<perspective>(*pc,_now,-1,a_move,a_cycle);
    } else if(frustum* fc = safe_cast<node,frustum>(*m_scene_camera)){
      new_cam = new camera_anim<frustum>(*fc,_now,-1,a_move,a_cycle);

    } else if(ortho* oc = safe_cast<node,ortho>(*m_scene_camera)){
      new_cam = new camera_anim<ortho>(*oc,_now,-1,a_move,a_cycle);
    } else if(lrbt* lc = safe_cast<node,lrbt>(*m_scene_camera)){
      new_cam = new camera_anim<lrbt>(*lc,_now,-1,a_move,a_cycle);

    } else {
      m_out << "inlib::sg::gui_viewer::start_cam_anim :"
                    << " camera not ortho and not perspective."
                    << std::endl;
      return;
    }

    grp->replace(m_scene_camera,new_cam,true); // it deletes m_scene_camera.
    set_scene_camera(new_cam,false); //WARNING : false

    enable_anim();
  }


public:
  static bool cmp_camera(const node& a_1,const node& a_2) {

    const ortho* oc1 = safe_cast<node,ortho>(a_1);
    const perspective* pc1 = safe_cast<node,perspective>(a_1);
    const lrbt* lc1 = safe_cast<node,lrbt>(a_1);
    const frustum* fc1 = safe_cast<node,frustum>(a_1);

    const ortho* oc2 = safe_cast<node,ortho>(a_2);
    const perspective* pc2 = safe_cast<node,perspective>(a_2);
    const lrbt* lc2 = safe_cast<node,lrbt>(a_2);
    const frustum* fc2 = safe_cast<node,frustum>(a_2);

    if(oc1 && oc2) return (*oc1)==(*oc2);
    if(pc1 && pc2) return (*pc1)==(*pc2);
    if(lc1 && lc2) return (*lc1)==(*lc2);
    if(fc1 && fc2) return (*fc1)==(*fc2);

    return false;
  }

public:
  //_switch& camera_menu_switch() {return m_camenu_switch;}
  //_switch& main_menu_switch() {return m_main_menu_switch;}

  /////////////////////////////////////////////////
  /// m_params ////////////////////////////////////
  /////////////////////////////////////////////////

#include "args2params.icc"

  bool args2camera(const std::vector<arg>& a_args,bool a_warn){
    //WARNING : used in for wall/screen_dispatch rwc_set_camera protocol.    
    if(!m_scene_camera) return false;

    bool status = true;

    // first pass to see if we have to swap the camera kind :
   {for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& label = a_args[index].first;
      const std::string& val = a_args[index].second;
      if(rcmp(label,s_camera_type())             ||
         rcmp(label,gui_params::s_camera_kind()) ){ //old wall data clients.

        bool to_swap = false;
        if((m_params.m_camera_type==s_camera_ortho())&&
           ((val==s_camera_perspective())||
            (val==gui_params::s_perspective())) ) //old wall data clients.
          to_swap = true;

        if((m_params.m_camera_type==s_camera_perspective())&&
           ((val==s_camera_ortho())||
            (val==gui_params::s_ortho())) )       //old wall data clients.
          to_swap = true;
          
        if(to_swap) {
          //if(!swap_scene_camera_kind()) { //FIXME : have to delete old cam !
          if(!swap_camera_kind()) {
            if(a_warn) {
              map_warn("swap camera kind failed");
            } else {
              m_out << "inlib::sg::gui_viewer::args2camera :"
                            << " swap camera kind failed."
                            << std::endl;
            }
            return false;
          }
        }
      }
    }}
  
    for(unsigned int index=0;index<a_args.size();index++) {
      const std::string& label = a_args[index].first;
      const std::string& val = a_args[index].second;

      if(rcmp(label,gui_params::s_cam_x())) {
        float field = m_scene_camera->position.value()[0];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[0] = field;
        }

      } else if(rcmp(label,gui_params::s_cam_y())) {
        float field = m_scene_camera->position.value()[1];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[1] = field;
        }

      } else if(rcmp(label,gui_params::s_cam_z())) {
        float field = m_scene_camera->position.value()[2];
        bool changed;
        if(!to<float>(field,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
          m_scene_camera->position.value()[2] = field;
        }

      } else if(rcmp(label,gui_params::s_cam_near())) {
        bool changed;
        if(!to<float>(m_scene_camera->znear.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_far())) {
        bool changed;
        if(!to<float>(m_scene_camera->zfar.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_focal())) {
        bool changed;
        if(!to<float>(m_scene_camera->focal.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_dx())) {
        bool changed;
        if(!to<float>(m_scene_camera->dx.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_da())) {
        bool changed;
        if(!to<float>(m_scene_camera->da.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_ds())) {
        bool changed;
        if(!to<float>(m_scene_camera->ds.value(),val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {
        }

      } else if(rcmp(label,gui_params::s_cam_zof())) {
        float v = -1;
        bool changed;
        if(!to<float>(v,val,changed)) {
          if(a_warn) {
            map_warn_nan();
            return false;
          } else {
            m_out << "inlib::sg::gui_viewer::args2camera :"
                          << " not a number."
                          << std::endl;
            status = false; //not fatal.
          }
        } else if(changed) {          
          m_scene_camera->zoom(v);
        }

      } else if(rcmp(label,gui_params::s_cam_orientation())) {
        if(!sqrot<vec3f,vec4f>(val,m_scene_camera->orientation.value(),::sinf,::cosf)) status = false;

      } else {
        if(a_warn) {
          map_warn(std::string("unknown param ")+label);
          return false;     
        } else {
          m_out << "inlib::sg::gui_viewer::args2camera : unknown param " << label << std::endl;
          status = false; //not fatal.
        }
      }
    }
    return status;     
  }

  //bool anim_shift() const {return m_params.m_anim_shift;}

  void set_params_camenu(const gui_params& a_params) {
    m_params = a_params;
    set_param_single_shoot(a_params.m_single_shoot);    
    set_param_90(a_params.m_90);    
    set_param_anim_shift(a_params.m_anim_shift);    
    set_param_anim_around_focal(a_params.m_anim_around_focal);    
    set_param_viewing(a_params.m_viewing);    
  }

  void set_param_anim_shift(bool a_value) {
    m_params.m_anim_shift = a_value;
    m_camenu_shift_button.set_label(anim_shift_button_label());
  }
  void toggle_param_anim_shift() {
    set_param_anim_shift(m_params.m_anim_shift?false:true);
  }

  void set_param_anim_around_focal(bool a_value) {
    m_params.m_anim_around_focal = a_value;
    if(m_params.m_plane_viewer) m_params.m_anim_around_focal = false;
    m_camenu_focal_button.set_label(around_focal_button_label());
  }
  void toggle_param_anim_around_focal() {
    set_param_anim_around_focal(m_params.m_anim_around_focal?false:true);
  }

  void set_param_viewing(bool a_value) {
    m_params.m_viewing = a_value;
    m_camenu_viewing_button.set_label(viewing_button_label());
    if(m_params.m_viewing){
      set_default_cursor_shape();
    } else {
      set_cursor_shape(cursor_target);
    }
  }
  void toggle_param_viewing() {
    set_param_viewing(m_params.m_viewing?false:true);
  }

  void set_param_90(bool a_value) {
    m_params.m_90 = a_value;
    if(m_params.m_plane_viewer) m_params.m_90 = false;
    if(m_params.m_image_buttons) {
      set_img(m_camenu_90_image_button,rot_90_image_button_file());
    } else {
      m_camenu_90_text_button.set_label(rot_90_button_label());
    }
  }
  void toggle_param_90() {set_param_90(m_params.m_90?false:true);}

  void set_param_single_shoot(bool a_value) {
    stop_cam_anim();

    m_params.m_single_shoot = a_value;
    if(m_params.m_single_shoot) stop_cam_anim();

    if(m_params.m_image_buttons) {
      set_img(m_camenu_sshoot_image_button,single_shoot_image_button_file());
    } else {
      m_camenu_sshoot_text_button.set_label(single_shoot_button_label());
    }
  }
  void toggle_param_single_shoot() {
    set_param_single_shoot(m_params.m_single_shoot?false:true);
  }

  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  void create_cursor() {
    //m_out << "inlib::sg::gui_viewer::create_cursor : " << std::endl;

    //mat4f old_mtx = m_cursor_matrix.mtx.value();

    m_cursor.clear();

   {depth_test* node = new depth_test;
    node->on = false;
    m_cursor.add(node);}

    // cam pos(0,0,1) near 0.1 far 10, menu pos in xy plan.
    float cam_height = 2;
    base_camera* camera = create_camera(camera_ortho,cam_height,0.1f);
    m_cursor_camera = camera;
    m_cursor.add(camera);

   {m_cursor_switch.clear();
    m_cursor.add(new noderef(m_cursor_switch));

    separator* full_sep = new separator;
    m_cursor_switch.add(full_sep);
    m_cursor_switch.add(new separator());
    m_cursor_switch.which = cursor_visible.value()?SHOWN():HIDDEN();

    rgba* mat = new rgba();
    mat->color = colorf_red();
    full_sep->add(mat);

    draw_style* ds = new draw_style;
    ds->style = draw_style::lines;
    ds->line_width = cursor_line_width;
    full_sep->add(ds);

    //m_cursor_matrix.mtx.value(old_mtx);
    full_sep->add(new noderef(m_cursor_matrix));

    vertices* vtcs = new vertices;

    vtcs->mode = gl::lines();

    if(cursor_model.value()==cursor_target) {
    
      float size = 0.1f;

      vtcs->add(-size, size,0);
      vtcs->add( size,-size,0);

      vtcs->add(-size,-size,0);
      vtcs->add( size, size,0);

    } else {

      float size = 0.2f;

      vtcs->add(0,-size,0);
      vtcs->add(0, size,0);

      vtcs->add(-size,0,0);
      vtcs->add( size,0,0);

/* various tentative definitly uglies.	
    } else {

      float hsq = 0.05f;

      // square :
      vtcs->add(-hsq,-hsq,0);
      vtcs->add( hsq,-hsq,0);

      vtcs->add( hsq,-hsq,0);
      vtcs->add( hsq, hsq,0);

      vtcs->add( hsq, hsq,0);
      vtcs->add(-hsq, hsq,0);

      vtcs->add(-hsq, hsq,0);
      vtcs->add(-hsq,-hsq,0);

      // lines to square :
      float end = 3*hsq;
      vtcs->add(-end,0,0);
      vtcs->add(-hsq,0,0);

      vtcs->add(end,0,0);
      vtcs->add(hsq,0,0);

      vtcs->add(0,end,0);
      vtcs->add(0,hsq,0);

      vtcs->add(0,-end,0);
      vtcs->add(0,-hsq,0);

    } else { //up_right_arrow

      float size = 0.2f;
      vtcs->add(   0,    0,0);
      vtcs->add(size,-size,0);

      vtcs->add(        0,0,0);
      vtcs->add(size*0.5f,0,0);

      vtcs->add(0,         0,0);
      vtcs->add(0,-size*0.5f,0);
*/
    }
    full_sep->add(vtcs);}

  }

public:
  bool find_exec_menu_item(const std::string& a_label) const {
    node* _node = current_list();
    if(!_node) return false;
    if(list* _list = safe_cast<node,list>(*_node)) {
      if(_list->find_exec_item(a_label)) return true;
    } else if(entries* _entries = safe_cast<node,entries>(*_node)) {
      if(_entries->cancel_label.value()!=a_label) return false;
      _entries->cbks().do_actions();
      return true;
    }
    return false;
  }
public:
  void set_memory_warning(bool a_value) {m_memory_warning = a_value;}
  bool has_memory_warning() {return m_memory_warning;}

  //bool add_jpeg_read_work(const std::string& a_file) {    
  //  if(!m_jpeg_data.open(a_file)) return false;
  //  add_work(new jpeg_read_work(*this,m_jpeg_data));
  //  return true;
  //}
  ////////////////////////////////////////////
  /// menu tab navigation system /////////////
  ////////////////////////////////////////////
protected:
  ptrs_t base_buttons() {
    search_action action(m_out);
    action.set_class(base_button::s_class());
    m_gui->search(action);
    return action.objs();
  }
  base_button* get_tab_current() {
    ptrs_t btns = base_buttons();
    if(m_tab_current<0) return 0;
    if(m_tab_current>=(int)btns.size()) return 0;
    return (base_button*)btns[m_tab_current];
  }
public:
  bool do_tab(bool a_shift) {
    ptrs_t btns = base_buttons();
    size_t btnn = btns.size();
    if((m_tab_current>=0)&&(m_tab_current<(int)btnn)) {
      base_button* btn = (base_button*)btns[m_tab_current];
      btn->disarm();
    }

    //::printf("debug : do_tab : btnn %d current %d\n",btnn,m_tab_current);

    if(a_shift) { // go back.
      m_tab_current--;
      if(m_tab_current<0) m_tab_current = int(btnn)-1;
    } else {
      m_tab_current++;
      if(m_tab_current>=(int)btnn) m_tab_current = 0;
    }

    bool to_render = false;
    if((m_tab_current>=0)&&(m_tab_current<(int)btnn)) {
      base_button* btn = (base_button*)btns[m_tab_current];
      btn->arm();
      btn->arm_color.touch();
      to_render = true;
    }
    return to_render;
  } 
  void do_return() {
    base_button* btn = get_tab_current(); 
    if(!btn) return;

    // ask to execute cbks by using the highly
    // protected ui::do_works.

    btn->disarm();

    add_work_cbks(btn->cbks().callbacks(),true);    

    m_tab_current--; //so that next tab be at same button position.
  } 

  void add_work_check_arm_buttons() {
    add_work(new check_arms_work(*this));
  }

public:
  ////////////////////////////////////////////
  /// common scenes //////////////////////////
  ////////////////////////////////////////////
  void visualize_text(const std::vector<std::string>& a_text,
    const std::vector<std::string>& a_rtext = std::vector<std::string>()) {

    hide_main_menu();
    clear_scene();
    if(!m_ww) return;
    if(!m_wh) return;
    if(a_text.empty()) return;

    // cam pos(0,0,1) near 0.1 far 10, primitives in xy plan.
    float cam_height = 2;
    float znear = 0.1f;
    base_camera* camera = create_camera(camera_ortho,cam_height,znear);
    if(!camera) return;

    separator* sep = new separator;
    m_scene->add(sep);

    camera->dx = cam_height/50.0f; //for 50 see touch_move.

    sep->add(camera);

    set_scene_camera(camera);
  
    rgba* mat = new rgba();
    mat->color = colorf_black();
    sep->add(mat);
  
    sep->add(new normal);

    matrix* m = new matrix;
    sep->add(m);
  
    float wcw,wch,aspect;
   {float tx,ty;
    get_gui_wcw_wch(wcw,wch,tx,ty,aspect);}

    infos_box* text = new infos_box(m_ttf);   
    text->width = wcw;
    text->back_visible = false;
    //text->hmargin_factor = 1.0f;
    //text->rhjust = left;
    text->font = m_params.m_gui_font;
    text->font_modeling = m_params.m_gui_font_modeling;
    sep->add(text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_text.begin();it!=a_text.end();++it) {
      text->lstrings.add(*it);
    }}

   {std::vector<std::string>::const_iterator it;
    for(it=a_rtext.begin();it!=a_rtext.end();++it) {
      text->rstrings.add(*it);
    }}

    text->update_sg(); //it sets text->height.

    mat4f& mtx = m->mtx.value();
    mtx.mul_translate(0,-text->height*0.5f+wch*0.5f,0);
  }

  void gui_text(const std::vector<std::string>& a_text){
    if(a_text.empty()) {
      map_warn_empty();
      return;
    }

    scroll_text* text = new scroll_text(m_ttf);
    set_style(*text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_text.begin();it!=a_text.end();++it) {
      text->text.add(*it);
    }}

    push_list(text);
  }

  void gui_text(const std::vector<std::string>& a_ltext,
                const std::vector<std::string>& a_rtext) {

    if(a_ltext.empty()) {
      map_warn_empty();
      return;
    }
    if(a_ltext.size()!=a_rtext.size()) {
      map_warn("size mismatch");
      return;
    }

    scroll_infos* text = new scroll_infos(m_ttf);
    set_style(*text);

   {std::vector<std::string>::const_iterator it;
    for(it=a_ltext.begin();it!=a_ltext.end();++it) {
      text->ltext.add(*it);
    }}
   {std::vector<std::string>::const_iterator it;
    for(it=a_rtext.begin();it!=a_rtext.end();++it) {
      text->rtext.add(*it);
    }}

    push_list(text);
  }

  base_camera* create_3D_camera(float a_radius){
    float cam_pos = 2*a_radius;
    float znear = 0.1f*a_radius;
    float near_height = 2 * znear * (a_radius/cam_pos);

    base_camera* camera =
      create_camera(camera_perspective,near_height,znear);
    if(!camera) {
      m_out << "inlib::sg::gui_viewer::create_3D_camera :"
            << " create_camera failed."
            << std::endl;
      return 0;
    }

    camera->zfar = 10*a_radius;
    camera->position = vec3f(0,0,cam_pos);
    camera->focal = cam_pos;

    camera->dx = 2.0f*a_radius/100.0f;
    //camera->da = camera->da.value()/2;

    return camera;
  }

  base_camera* create_2D_camera(float a_height) { //for image, plots
    float z = 10*a_height;
    float znear = 0.1f*z;
    base_camera* cam = create_camera(camera_ortho,a_height,znear);
    if(!cam) {
      m_out << "inlib::sg::gui_viewer::create_2D_camera :"
            << " create_camera failed."
            << std::endl;
      return 0;
    }
    cam->zfar = 10*z;
    cam->position = vec3f(0,0,z);
    cam->orientation = rotf(vec3f(0,0,1),0);
    cam->focal = z;
    cam->dx = a_height/100.0f;
    return cam;
  }
  base_camera* create_camera(base_camera& a_cam){
    base_camera* camera = 0;
    if(safe_cast<node,ortho>(a_cam)) {
      camera = create_camera(camera_ortho,a_cam.near_height(),a_cam.znear);
    } else if(safe_cast<node,perspective>(a_cam)){
      camera = create_camera(camera_perspective,a_cam.near_height(),a_cam.znear);
    }
    if(!camera) return 0;    

    camera->zfar = a_cam.zfar;
    camera->position = a_cam.position;
    camera->orientation = a_cam.orientation;

    camera->dx = a_cam.dx;
    camera->da = a_cam.da;
    camera->ds = a_cam.ds;
    camera->focal = a_cam.focal;

    return camera;
  }

public:
  bool do_key(key_move a_key,bool a_shift,bool a_ctrl) {
    if(a_ctrl) {

      if(cam_anim_is_running()) {
        stop_cam_anim();

      } else {

        anim_what anim = anim_left;
        if(a_key==key_left)
          anim = anim_left;
        else if(a_key==key_right)
          anim = anim_right;
        else if(a_key==key_up)
          anim = anim_up;
        else if(a_key==key_down)
          anim = anim_down;

        // do we want to change things in the cam panel ?
        // Huum, yes as long as m_params.m_anim_shift
        // belongs to gui_viewer.
        set_param_anim_shift(a_shift);

        start_cam_anim(anim,a_shift,m_params.m_cycle_secs);
      }
      return false; //do not render.

    } else {
      if(a_key==key_left)
        update_anim_motion(anim_left,a_shift);
      else if(a_key==key_right)
        update_anim_motion(anim_right,a_shift);
      else if(a_key==key_up)
        update_anim_motion(anim_up,a_shift);
      else if(a_key==key_down)
        update_anim_motion(anim_down,a_shift);

      return true; //to render.
    }
  } 

public:
  // actions :
  static return_action action_none(gui_viewer&) {return return_none;}
  
  static return_action action_hide(gui_viewer&,_switch& a_widget) {
    if(a_widget.which==1) return return_none;
    a_widget.which = 1;
    return return_to_render;     
  }

  static return_action action_touch_down(gui_viewer& a_gv,const ecbk& a_cbk) {
    if(!a_cbk.m_node) return return_none;            
    if(base_button* btn = safe_cast<node,base_button>(*a_cbk.m_node)){
      a_gv.arm_button(btn);
      a_cbk.m_event_action->set_done(true);
    } else if(slider* sd = safe_cast<node,slider>(*a_cbk.m_node)){
      a_gv.add_work_cbks(sd->begs(),true);    
      a_cbk.m_event_action->set_done(true);
    }
    return return_none;
  }

  static return_action action_touch_up(gui_viewer& a_gv,const ecbk& a_cbk) {
    if(!a_cbk.m_node) return return_none;            
    if(base_button* btn = safe_cast<node,base_button>(*a_cbk.m_node)){
      a_gv.trigger_button(btn);
      a_cbk.m_event_action->set_done(true);
    } else if(slider* sd = safe_cast<node,slider>(*a_cbk.m_node)){
      a_gv.add_work_cbks(sd->ends(),true);    
      a_cbk.m_event_action->set_done(true);
    } else if(ghost* gh = safe_cast<node,ghost>(*a_cbk.m_node)){
      //m_out << "inlib::sg::gui_viewer::touch_up :" 
      //      << " pick ghost."
      //      << std::endl;
      a_gv.add_work_cbks(gh->cbks().callbacks(),true);    
      a_cbk.m_event_action->set_done(true);
    }
    return return_none;
  }
  static return_action action_touch_move(gui_viewer& a_gv,const ecbk& a_cbk) {
    if(!a_cbk.m_node) return return_none;            
    if(slider* sd = safe_cast<node,slider>(*a_cbk.m_node)){
      // we have to update the slider pos :
      if(move_event* mevt = event_cast<event,move_event>(*a_cbk.m_event)){
        sd->set_value(a_cbk.m_event_action->saved_state(),*mevt);
      }
      a_gv.add_work_cbks(sd->drags(),true);      
      a_gv.m_motion_slider = sd;
      a_cbk.m_event_action->set_done(true);
    }
    return return_none;
  }

  static return_action action_export_png(gui_viewer& a_gv) {
    a_gv.hide_popup();
    a_gv.hide_main_menu();
    a_gv.hide_camera_menu();
    //bool old_border = a_gv.plots().view_border;
    //a_gv.plots().view_border = false;
    a_gv.set_produce_out_png(true);
    //send_restore(old_border);
    return return_to_render;     
  }

#define ACTION_GUI_RENDER(a__method) \
  static return_action action_##a__method(gui_viewer& a_gv) {a_gv.a__method();return return_to_render;}

  ACTION_GUI_RENDER(push_home)           //home
  ACTION_GUI_RENDER(push_back_item)      //back
  ACTION_GUI_RENDER(pop_list)            //last

  ACTION_GUI_RENDER(activate_meta_zone)
  ACTION_GUI_RENDER(hide_popup)

  ACTION_GUI_RENDER(adapt_camera_to_scene)
  ACTION_GUI_RENDER(reset_camera)
  ACTION_GUI_RENDER(clear_scene)

  ACTION_GUI_RENDER(toggle_param_single_shoot)      //action_single_shoot
  ACTION_GUI_RENDER(toggle_param_90)                //action_90
  ACTION_GUI_RENDER(toggle_param_anim_shift)        //action_anim_shift
  ACTION_GUI_RENDER(toggle_param_anim_around_focal) //action_anim_around_focal
  ACTION_GUI_RENDER(toggle_param_viewing)           //action_viewing
  ACTION_GUI_RENDER(hide_camera_menu)               //action_hide_camenu
  ACTION_GUI_RENDER(show_camera_menu)               //action_show_camenu

//ACTION_GUI_RENDER(start_anim_around_focal)
  ACTION_GUI_RENDER(count_points) 
  ACTION_GUI_RENDER(toggle_light)
  ACTION_GUI_RENDER(toggle_gsto)
  ACTION_GUI_RENDER(toggle_plane_exam)
  ACTION_GUI_RENDER(swap_scene_clear_color)
  ACTION_GUI_RENDER(swap_camera_kind)
  ACTION_GUI_RENDER(enable_anim)
  ACTION_GUI_RENDER(disable_anim)

#undef ACTION_GUI_RENDER

  INLIB_CLASS_STRING(ui_style)

  static return_action action_params_ok(gui_viewer& a_gv,entries& a_widget) {
    std::string ui_style;

    const std::vector<std::string>& labels = a_widget.labels.values();
    const std::vector<std::string>& vals = a_widget.values.values();

    std::vector<arg> args;
    for(unsigned int index=0;index<labels.size();index++) {
      const std::string& label = labels[index];
      const std::string& val = vals[index];
      if(label==s_ui_style()) {
        ui_style = val;
      } else {
        args.push_back(arg(label,val));
      }
    }

    if(!a_gv.args2params(args,true)) return return_to_render;

    if(ui_style.size()&&(ui_style!=a_gv.m_gui_style)) {
      // if style changed, it override m_params.m_image_buttons.
      if(ui_style==s_default()) {
        a_gv.m_params.set_gui_default();
      } else {
        a_gv.set_gui_style(ui_style);
      }
      a_gv.push_home(); //to reset style of central menu.
    }
    return return_to_render;
  }

  static return_action action_params_show(gui_viewer& a_gv) {
    entries* node = new entries(a_gv.m_ttf);
    node->entry_label_result_factor = 0.7f;

    std::vector<std::string> modes;
    a_gv.m_render_manager.available_gsto_modes(modes);
    params2entries(a_gv.m_params,*node,a_gv.is_wall_screen_app(),modes);

   {std::vector<std::string> opts;
    opts.push_back(s_camera_ortho());
    a_gv.m_styles.find_styles("gui_*",opts);
    opts.push_back(s_default());
    node->add_opts(s_ui_style(),a_gv.m_gui_style,opts);}

    add_callback(a_gv,*node,action_params_ok,pos_data(false,0,0));
  
    a_gv.set_style(*node);
    a_gv.push_list(node);

    return return_to_render;
  }

  static return_action action_move_camera(gui_viewer& a_gv,anim_what a_action) {
    //a_gv.stop_cam_anim(); //???

    if(a_gv.m_params.m_90 && !a_gv.m_params.m_plane_viewer) {

           if(a_action==anim_left)  a_gv.m_scene_camera->rotate_around_y_at_focal(-fhalf_pi());
      else if(a_action==anim_right) a_gv.m_scene_camera->rotate_around_y_at_focal(fhalf_pi());
      else if(a_action==anim_up)    a_gv.m_scene_camera->rotate_around_x_at_focal(-fhalf_pi());
      else if(a_action==anim_down)  a_gv.m_scene_camera->rotate_around_x_at_focal(fhalf_pi());

      return return_to_render;     
    }

    if(a_gv.m_params.m_single_shoot) {

      a_gv.update_anim_motion(a_action,a_gv.m_params.m_anim_shift);

    } else {
      if(a_gv.cam_anim_is_running()) {
        a_gv.stop_cam_anim();
      } else {             
        a_gv.start_cam_anim(a_action,a_gv.m_params.m_anim_shift,a_gv.m_params.m_cycle_secs);
      }
    }
    return return_to_render;
  }

  static return_action action_left(gui_viewer& a_gv)  {return action_move_camera(a_gv,anim_left);}
  static return_action action_right(gui_viewer& a_gv) {return action_move_camera(a_gv,anim_right);}
  static return_action action_up(gui_viewer& a_gv)    {return action_move_camera(a_gv,anim_up);}
  static return_action action_down(gui_viewer& a_gv)  {return action_move_camera(a_gv,anim_down);}

  ///////////////////////////////////////////
  /// camed : ///////////////////////////////
  ///////////////////////////////////////////
  static return_action action_cam_set_params(gui_viewer& a_gv,entries& a_widget) {
    base_camera* cam = a_gv.scene_camera();
    if(!cam) {
      a_gv.map_warn("no camera found.");
      return return_to_render;     
    }
  
   {float x;
    if(!a_gv.tow<float>(a_widget.values[0],x)) return return_to_render;
    float y;
    if(!a_gv.tow<float>(a_widget.values[1],y)) return return_to_render;
    float z;
    if(!a_gv.tow<float>(a_widget.values[2],z)) return return_to_render;  
    cam->position.value().set_value(x,y,z);}
  
    if(!sqrot<vec3f,vec4f>(a_widget.values[3],cam->orientation.value(),::sinf,::cosf)) return return_to_render;

   {float v;
    if(!a_gv.tow<float>(a_widget.values[4],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;     
    }
    cam->znear = v;}
  
   {float v;
    if(!a_gv.tow<float>(a_widget.values[5],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;     
    }
    if(v<=cam->znear.value()) {
      a_gv.map_warn("far must be > near");
      return return_to_render;     
    }
    cam->zfar = v;}
  
   {float v;
    if(!a_gv.tow<float>(a_widget.values[6],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;     
    }
    cam->focal = v;}
  
   {float v;
    if(!a_gv.tow<float>(a_widget.values[7],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;     
    }
    cam->dx = v;}
  
   {float v;
    if(!a_gv.tow<float>(a_widget.values[8],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;     
    }
    cam->da = v*fdeg2rad();}
  
   {float v;
    if(!a_gv.tow<float>(a_widget.values[9],v)) return return_to_render;
    if(v<=0) {
      a_gv.map_warn("must be >0");
      return return_to_render;     
    }
    cam->ds = v;}
  
    if(a_gv.is_wall_screen_app()) {
      float v;
      if(!a_gv.tow<float>(a_widget.values[10],v)) return return_to_render;
      if(v<=0) {
        a_gv.map_warn("must be >0");
        return return_to_render;     
      }
      cam->zoom(v);
    } else {
      float v;
      if(!a_gv.tow<float>(a_widget.values[10],v)) return return_to_render;
      if(v<=0) {
        a_gv.map_warn("must be >0");
        return return_to_render;     
      }
      if(ortho* oc = safe_cast<node,ortho>(*cam)) {
        oc->height = v;
      } else if(perspective* pc = safe_cast<node,perspective>(*cam)) {
        pc->height_angle = v*fdeg2rad();   
      }
    }
  
    a_gv.hide_main_menu();
    return return_to_render;  
  }

  static return_action action_cam_set_type(gui_viewer& a_gv,entries& a_widget) {
    //change cam class if needed and present entries for params.
        
    std::string skind = a_widget.values[0];
    //a_gv.out() << "choosen class " << scls << std::endl;
    if(skind.size() && a_gv.m_params.m_camera_type.size() && (skind!=a_gv.m_params.m_camera_type)) {
      if(!a_gv.swap_camera_kind()) {
        a_gv.map_warn("swap_camera_kind() failed.");
        return return_to_render;     
      }          
    }

    base_camera* new_cam = a_gv.scene_camera();
    if(!new_cam) {
      a_gv.map_warn("no camera found.");
      return return_to_render;     
    }
  
    entries* _entries = new entries(a_gv.m_ttf);
    _entries->label = "camera";
    a_gv.set_style(*_entries);
  
    _entries->add_float("x",new_cam->position.value().x());    //0
    _entries->add_float("y",new_cam->position.value().y());    //1
    _entries->add_float("z",new_cam->position.value().z());    //2
   {std::string s;
    if(!tos(new_cam->orientation.value(),s)) s = "0 1 0 0";
    _entries->add_string("orientation",s);}                    //3
    _entries->add_float("near",new_cam->znear.value());        //4
    _entries->add_float("far",new_cam->zfar.value());          //5
    _entries->add_float("focal",new_cam->focal.value());       //6
    _entries->add_float("dx",new_cam->dx.value());             //7
    _entries->add_float("da (deg)",new_cam->da.value()*frad2deg()); //8
    _entries->add_float("ds (for zoom)",new_cam->ds.value());  //9
    if(a_gv.is_wall_screen_app()) {
      _entries->add_float("zoom out",1);     //10
    } else {
      if(ortho* oc =
         safe_cast<node,ortho>(*new_cam)){
        _entries->add_float("height",oc->height.value()); //10
      } else if(perspective* pc = 
         safe_cast<node,perspective>(*new_cam)){
        _entries->add_float("height angle (deg)",pc->height_angle.value()*frad2deg()); //10
      } else {
        a_gv.map_warn("unhandled camera type");
        return return_to_render;     
      }
    }
  
    add_callback(a_gv,*_entries,action_cam_set_params,pos_data(false,0,0));
  
    a_gv.push_list(_entries);

    return return_to_render;
  }

  static return_action action_cam_choose_type(gui_viewer& a_gv) {
    if(a_gv.m_params.m_camera_type.empty()) {
      a_gv.map_warn("no camera");
      return return_to_render;     
    }

    entries* _entries = new entries(a_gv.m_ttf);
    _entries->label = "camera";
    a_gv.set_style(*_entries);

    std::vector<std::string> opts;
    opts.push_back(s_camera_ortho());
    opts.push_back(s_camera_perspective());
    _entries->add_opts("kind",a_gv.m_params.m_camera_type,opts);

    add_callback(a_gv,*_entries,action_cam_set_type,pos_data(false,0,0));

    a_gv.push_list(_entries);

    a_gv.show_main_menu(); //needed if triggered from cam panel.

    return return_to_render;
  }

  static return_action action_cam_set_anim(gui_viewer& a_gv,entries& a_widget) {
    base_camera* cam = a_gv.scene_camera();
    if(!cam) {
      a_gv.map_warn("no camera found.");
      return return_to_render;     
    }
  
    std::string sanim = a_widget.values[0];

    unsigned int cycle;
    if(!a_gv.tow<unsigned int>(a_widget.values[1],cycle)) return return_to_render;     

    if(sanim==s_zoom_in_out()) {
      a_gv.start_cam_move(move_zoom_in_out,cycle);
      a_gv.hide_main_menu();
    } else if(sanim==s_zoom_in_out_rot()) {
      a_gv.start_cam_move(move_zoom_in_out_rot,cycle);
      a_gv.hide_main_menu();
    } else {
      a_gv.map_warn("unknown anim.");
    }

    return return_to_render;
  }

  static return_action action_cam_choose_anim(gui_viewer& a_gv) {
    if(a_gv.m_params.m_camera_type.empty()) {
      a_gv.map_warn("no camera");
      return return_to_render;     
    }

    entries* _entries = new entries(a_gv.m_ttf);
    _entries->label = "camera anim";
    a_gv.set_style(*_entries);

    std::vector<std::string> opts;
    opts.push_back(s_zoom_in_out());
    opts.push_back(s_zoom_in_out_rot());
    _entries->add_opts("anim",s_zoom_in_out(),opts);

    _entries->add_uint("cycle (secs)",10);

    add_callback(a_gv,*_entries,action_cam_set_anim,pos_data(false,0,0));

    a_gv.push_list(_entries);

    a_gv.show_main_menu(); //needed if triggered from cam panel.

    return return_to_render;
  }

  // old rwc_gui actions id :
/*
    static unsigned int action_reset_camera() {return 9;}    
    static unsigned int action_single_shoot()      {return 4;}
    static unsigned int action_90()                {return 5;}
    static unsigned int action_anim_shift()        {return 6;}
    static unsigned int action_anim_around_focal() {return 7;}
    static unsigned int action_viewing()           {return 8;}
    static unsigned int action_clear_scene()             {return 21;}
    static unsigned int action_cam_anim_zoom_in_out()     {return 40;}
    static unsigned int action_cam_anim_zoom_in_out_rot() {return 41;}

      } else if(m_action==action_cam_anim_zoom_in_out()) {     //from rwc.
        m_gv.start_cam_move(move_zoom_in_out,m_gv.m_params.m_cycle_secs);
        m_gv.hide_main_menu();
      } else if(m_action==action_cam_anim_zoom_in_out_rot()) { //from rwc.
        m_gv.start_cam_move(move_zoom_in_out_rot,m_gv.m_params.m_cycle_secs);
        m_gv.hide_main_menu();
*/  

protected:

  ////////////////////////////////////////////////////
  /// works //////////////////////////////////////////
  ////////////////////////////////////////////////////

  class check_arms_work : public bcbk {
  public:
    virtual return_action action() {
      std::vector<base_button*>::iterator it;
      for(it=m_gv.m_arm_buttons.begin();it!=m_gv.m_arm_buttons.end();++it) {
        if(m_gv.search_button(*it)){
          (*it)->disarm();
          (*it)->arm_color.touch(); //touch something.
        }
      }    
      m_gv.m_arm_buttons.clear();
      return return_to_render;     
    }
    virtual bcbk* copy() const {return new check_arms_work(*this);}
  public:
    check_arms_work(gui_viewer& a_gv):bcbk(),m_gv(a_gv) {
      m_single_shoot = true;
    }
    virtual ~check_arms_work(){}
  public:
    check_arms_work(const check_arms_work& a_from)
    :bcbk(a_from),m_gv(a_from.m_gv){}
    check_arms_work& operator=(const check_arms_work& a_from){
      bcbk::operator=(a_from);
      return *this;
    }
  protected:
    gui_viewer& m_gv;
  };

  class arm_work : public bcbk {
    INLIB_HEADER_COPY(arm_work,inlib::sg::gui_viewer::arm_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //WARNING : m_button could have been deleted by some cbk.
      //          (Case of a timer work that would do an indirect gui_visible.touch()
      //           which would induce a delete of buttons in the win_render() -> render()
      //           and then check_gui_curosr()).
      //if(m_gv.search_button(m_button)){
        m_button->arm();
        m_button->arm_color.touch(); //touch something.
      //} else {
      //  m_gv.out() << "arm_work : warning : anomaly : button does not exist." << std::endl;
      //}
      return return_to_render;     
    }
  public:
    arm_work(gui_viewer& a_gv,base_button* a_button)
    :parent()
    ,m_gv(a_gv)
    ,m_button(a_button)
    {
      m_single_shoot = true;
    }
    virtual ~arm_work(){}
  public:
    arm_work(const arm_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_button(a_from.m_button)
    {}
    arm_work& operator=(const arm_work& a_from){
      parent::operator=(a_from);
      m_button = a_from.m_button;
      return *this;
    }
  protected:
    gui_viewer& m_gv;
    base_button* m_button;
  };

  class disarm_work : public bcbk {
    INLIB_HEADER_COPY(disarm_work,inlib::sg::gui_viewer::disarm_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //WARNING : m_button could have be deleted by some cbk.
      //if(m_gv.search_button(m_button)){
        m_button->disarm();
        m_button->arm_color.touch(); //touch something.
      //} else {
      //  m_gv.out() << "disarm_work : warning : anomaly : button does not exist." << std::endl;
      //}
      return return_to_render;     
    }
  public:
    disarm_work(gui_viewer& a_gv,base_button* a_button)
    :parent()
    ,m_gv(a_gv)
    ,m_button(a_button)
    {
      m_single_shoot = true;
    }
    virtual ~disarm_work(){}
  public:
    disarm_work(const disarm_work& a_from)
    :parent(a_from)
    ,m_gv(a_from.m_gv)
    ,m_button(a_from.m_button)
    {}
    disarm_work& operator=(const disarm_work& a_from){
      parent::operator=(a_from);
      m_button = a_from.m_button;
      return *this;
    }
  protected:
    gui_viewer& m_gv;
    base_button* m_button;
  };


  class anim_work : public bcbk {
    INLIB_HEADER_COPY(anim_work,inlib::sg::gui_viewer::anim_work,bcbk,bcbk)
  public:
    virtual return_action action() {
      //m_gv.out() << "debug : anim_work::action" << std::endl;
      if(m_gv.treat_anim(atime::now())) return return_to_render;     
      return return_none;     
    }
  public:
    anim_work(gui_viewer& a_gv)
    :bcbk()
    ,m_gv(a_gv)
    {}
    virtual ~anim_work(){}
  public:
    anim_work(const anim_work& a_from)
    :bcbk(a_from)
    ,m_gv(a_from.m_gv)
    {}
    anim_work& operator=(const anim_work& a_from){
      bcbk::operator=(a_from);
      return *this;
    }
  protected:
    gui_viewer& m_gv;
  };

  class to_stop_event_anim { //used with holder<>.
  public:
    INLIB_SCLASS(inlib::sg::gui_viewer::to_stop_event_anim)
  public:
    to_stop_event_anim(gui_viewer& a_gv):m_gv(a_gv) {}
    virtual ~to_stop_event_anim() {m_gv.stop_event_anim();}
  protected:
    to_stop_event_anim(const to_stop_event_anim& a_from):m_gv(a_from.m_gv) {}
    to_stop_event_anim& operator=(const to_stop_event_anim&){return *this;}
  protected:
    gui_viewer& m_gv;
  };

protected:
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  ///////////////////////////////////////////////////
  typedef std::map<std::string,base_dumper*> dumpers_t;
public:
  void set_argcv(const args& a_args) {m_argcv = a_args;}
  const args& argcv() const {return m_argcv;}
  args& argcv() {return m_argcv;}
  
  //const dumpers_t& dumpers() const {return m_dumpers;}
  //dumpers_t& dumpers() {return m_dumpers;}
  void add_dumper(const std::string& a_key,base_dumper* a_dumper) { //take ownership of a_dumper.
    add_unique(m_dumpers,a_key,a_dumper,true); //true=delete existing dumper on a_key.
  }
  bool exec_dumper(list& a_list,const std::string& a_name,const std::string& a_tag) {
    dumpers_t::const_iterator itd = m_dumpers.find(a_name);
    if(itd==m_dumpers.end()) return false;
    std::vector<std::string> infos;
    (*itd).second->get_infos(a_tag,infos);
    inlib_vforcit(std::string,infos,it)
      a_list.add(*it,new fundata_cbk<gui_viewer,list,pos_data>(*this,a_list,action_none,pos_data(false,0,0)));
    return true;
  }
/*
  bool add_popup_dumper(const std::string& a_name,const std::vector<std::string>& a_v) {
    dumpers_t::const_iterator it = m_dumpers.find(a_name);
    if(it!=m_dumpers.end()) return false; //done
    m_dumpers[a_name] = new popup_dumper(*this,a_v);
    return true;
  }
*/
public:
  bool set_img_from_res_file(const std::string& a_file,img_byte& a_img) {
    if(a_file.empty()) {a_img.clear();return true;}
    std::string path = m_res_dir;
    path += sep();
    path += a_file;
    inlib_vforcit(image::readers::named_reader,m_image_readers.named_readers(),it) {
      image::ireader* _reader = (*it).second;
      if(!_reader->is(path)) continue;
      unsigned int w,h,bpp;
      unsigned char* buffer = _reader->read(m_out,path,w,h,bpp);
      if(!buffer) continue;
      a_img.set(w,h,bpp,buffer,true);
      return true;
    }  
    a_img.clear();
    return false;
  }

public: //commands
  bool insh_exec(const std::string& a_file,bool a_verbose) {
    if(!file::exists(a_file)) {    
      m_out << "inlib::sg::gui_viewer::insh_exec : " << a_file << " order file not found." << std::endl;
      return false;
    }
    std::vector<std::string> lines;
    if(!file::read(a_file,lines)) {
      m_out << "inlib::sg::gui_viewer::insh_exec : can't read " << a_file << "." << std::endl;
      return false;
    }
    
    inlib_vforcit(std::string,lines,it) {
      if(to_exit()) break;
      
      const std::string& line = *it;
      if(line.empty()) continue;
      if(line.substr(0,1)=="#") continue;
      if(a_verbose) m_out << "inlib::sg::gui_viewer::insh_exec : exec line : " << sout(line) << std::endl;

      std::vector<std::string> ws;
      words(line," ",false,ws);
      std::string cmd = ws[0];

      ws.erase(ws.begin());

     {std::string s_cmd("exec_menu_item");
      if(cmd==s_cmd) {
        if(line.size()<(s_cmd.size()+1)) {
          m_out << "inlib::sg::gui_viewer::insh_exec : empty menu item. Stop." << std::endl;
	  break;
	}
        std::string rest = line.substr(s_cmd.size()+1,line.size()-(s_cmd.size()+1));
        if(!find_exec_menu_item(rest)) {
          m_out << "inlib::sg::gui_viewer::insh_exec : menu item " << sout(rest) << " not found. Stop." << std::endl;
	  break;
        }
	continue;
      }}

      if(!insh_dispatch(cmd,ws)) {
        m_out << "inlib::sg::gui_viewer::insh_exec : WARNING : command " << sout(cmd) << " not found for line " << line << "."
	      << " Stop exec file " << sout(a_file) << "." << std::endl;
        break;
      }

    }

    return true;
  }

#define DISPATCH_COMMAND(a__name) \
    if(a_cmd==#a__name) {\
      a__name();\
      return true;\
    }
    
  virtual bool insh_dispatch(const std::string& a_cmd,const std::vector<std::string>& a_args) {
    DISPATCH_COMMAND(adapt_camera_to_scene)
    DISPATCH_COMMAND(swap_camera_kind)
    DISPATCH_COMMAND(hide_console)
    DISPATCH_COMMAND(show_console)
    DISPATCH_COMMAND(hide_main_menu)
    DISPATCH_COMMAND(show_main_menu)
    DISPATCH_COMMAND(hide_camera_menu)
    DISPATCH_COMMAND(show_camera_menu)
    DISPATCH_COMMAND(clear_scene)
    DISPATCH_COMMAND(push_home)
    DISPATCH_COMMAND(push_back_item)

    if(a_cmd=="open_res") {
      if(a_args.size()==1) {
        std::string path = res_dir()+sep()+a_args[0];
        bool done;
        if(!opener().open(path,file::s_format_guessed(),args(),done)) {
          m_out << "inlib::sg::gui_viewer::insh_exec : opener.open() failed for " << sout(path) << "." << std::endl;
          set_to_exit();
	}
      } else {
        m_out << "inlib::sg::gui_viewer::insh_exec : command " << sout(a_cmd) << " expects one orgument." << std::endl;
	set_to_exit();
      }
      return true;      
    }

    if(a_cmd=="open") {
      if(a_args.size()==1) {
        const std::string& path = a_args[0];
        bool done;
        if(!opener().open(path,file::s_format_guessed(),args(),done)) {
          m_out << "inlib::sg::gui_viewer::insh_exec : opener.open() failed for " << sout(path) << "." << std::endl;
          set_to_exit();
	}
      } else {
        m_out << "inlib::sg::gui_viewer::insh_exec : command " << sout(a_cmd) << " expects one orgument." << std::endl;
        set_to_exit();
      }
      return true;
    }
    
    if(a_cmd=="light_on") {
      set_scene_light_on(true);
      return true;      
    }

    if(a_cmd=="light_off") {
      set_scene_light_on(false);
      return true;
    }

    if(a_cmd=="camera_rotate_around_y_half_pi") {
      base_camera* _cam = scene_camera();
      if(_cam) _cam->rotate_around_y_at_focal(fhalf_pi());
      return true;      
    }

    if(a_cmd=="camera_rotate_around_y_minus_half_pi") {
      base_camera* _cam = scene_camera();
      if(_cam) _cam->rotate_around_y_at_focal(-fhalf_pi());
      return true;      
    }

    if(a_cmd=="camera_rotate_around_y_fourth_pi") {
      base_camera* _cam = scene_camera();
      if(_cam) _cam->rotate_around_y_at_focal(fhalf_pi()*0.5f);
      return true;      
    }


    if(a_cmd=="camera_zoom") {
      if(a_args.size()==1) {
        const std::string& arg_0 = a_args[0];
        float factor;
	if(!to(arg_0,factor)) {
          m_out << "inlib::sg::gui_viewer::insh_exec : for command " << sout(a_cmd)
	        << ", first argument " << sout(arg_0) << " is not a float." << std::endl;
          set_to_exit();
	} else {
	  if(factor<=0) {
            m_out << "inlib::sg::gui_viewer::insh_exec : for command " << sout(a_cmd)
                  << ", first argument " << sout(arg_0) << " must be >0." << std::endl;
            set_to_exit();
	  } else {
            //  factor = 0.99f is a zoom in
            //  factor = 1.01f is a zoom out
            base_camera* _cam = scene_camera();
            if(_cam) _cam->zoom(factor);
          }
	}
      } else {
        m_out << "inlib::sg::gui_viewer::insh_exec : command " << sout(a_cmd) << " expects one orgument." << std::endl;
        set_to_exit();
      }
      return true;      
    }

    //0.1 is more close than 0.2.
   {for(unsigned int index=1;index<=9;index++) {
      std::string sindex;
      if(!num2s(index,sindex)){}
      if(a_cmd=="camera_zoom_0_"+sindex) {
        base_camera* _cam = scene_camera();
        if(_cam) _cam->zoom(0.1f*index);
        return true;      
      }
    }}
    
    return false;
  }

#undef DISPATCH_COMMAND

protected:

  void check_gui_cursor() {
    if(gui_visible.touched()){
      create_gui();
      gui_visible.reset_touched();
    }

    if( cursor_visible.touched()    ||
        cursor_line_width.touched() ||
        cursor_model.touched()      ){
      //m_out << "debug : inlib::sg::gui_viewer::render : create_cursor."
      //      << std::endl;
      create_cursor();
      cursor_visible.reset_touched();
      cursor_line_width.reset_touched();
      cursor_model.reset_touched();
    }
  }
protected:
  bool search_button(base_button* a_node) {
    search_action action(m_out);
    action.set_class(base_button::s_class());
    m_gui->search(action);
    const ptrs_t& objs = action.objs();
    ptrs_t::const_iterator it;
    for(it=objs.begin();it!=objs.end();++it) {
      if(a_node==(*it)) return true;
    }    
    return false;    
  }
protected:
  render_manager& m_render_manager;
  const base_freetype& m_ttf;
  sg::zb_manager m_zb_mgr; //sg is needed.

private:
  selection* m_scene;
protected:
  //selection m_backup_scene;

  base_camera* m_scene_camera;
  node* m_reset_camera;
  torche* m_scene_light;

private:
  selection* m_gui;
protected:
  separator m_full_sep;

  _switch m_scene_switch;
  _switch m_main_menu_switch;
  _switch m_camenu_switch;
  separator m_camenu_sep;

  text_button m_camenu_shift_button;
  image_button m_camenu_sshoot_image_button;
  text_button m_camenu_sshoot_text_button;
  image_button m_camenu_90_image_button;
  text_button m_camenu_90_text_button;
  text_button m_camenu_focal_button;  
  text_button m_camenu_viewing_button;  
  text_button m_camenu_gsto_button;  
  text_button m_camenu_plane_exam_button;

  _switch m_gui_sliders_switch;
  _switch m_sliders_switch;
  matrix m_slider_1_matrix;
  matrix m_slider_2_matrix;
  matrix m_slider_3_matrix;
  matrix m_slider_4_matrix;
  slider m_slider_1;
  slider m_slider_2;
  slider m_slider_3;
  slider m_slider_4;
  separator m_hide_sliders_sep;
  matrix m_hide_sliders_matrix;

  _switch m_console_switch;
  matrix m_console_matrix;
  text_button m_console;

  _switch m_popup_switch;
  separator m_popup_sep;
  matrix m_popup_matrix;
  sg::cbks m_popup_cbks;

  _switch m_progress_switch;
  sg::progress m_progress;

  bool m_meta_had_been_shown;
  _switch m_meta_switch;

  std::vector<base_button*> m_tab_buttons;
  int m_tab_current; //could be (-1)
 
  std::vector<base_button*> m_arm_buttons;

  bool m_touch_in_motion; // X11, Android :
  int m_touch_prev_x;
  int m_touch_prev_y;

  unsigned int m_gesture_begin_x;
  unsigned int m_gesture_begin_y;
  node* m_gesture_begin_camera;

  slider* m_motion_slider;

  bool m_treat_mouse_motion;

  //wall :
  separator m_cursor;
  _switch m_cursor_switch;
  base_camera* m_cursor_camera;
  matrix m_cursor_matrix;

  bool m_memory_warning;
  group m_tmp_group; //to deposit sg::holder to data.

  action_prots_t m_action_prots;
  //end wall.

  dumpers_t m_dumpers;  
  inlib::opener m_opener; //inlib:: needed.
  image::readers m_image_readers;

  bool m_vr_mode;
  args m_argcv;
};

inline gui_viewer* cast_gui_viewer(viewer& a_viewer) {
  return safe_cast<viewer,gui_viewer>(a_viewer);
}

/////////////////////////////////////////////////////////////////////////////
/// list and action : ///////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

template <class FUNC,class DATA>
inline void add_item(gui_viewer& a_gv,ilist& a_widget,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  a_widget.add(a_label,new fundata_cbk<gui_viewer,ilist,DATA>(a_gv,a_widget,a_func,a_data));
}

template <class FUNC>
inline void add_item(gui_viewer& a_gv,ilist& a_widget,const std::string& a_label,FUNC a_func) {
  a_widget.add(a_label,new fundata_cbk<gui_viewer,ilist,pos_data>(a_gv,a_widget,a_func,pos_data(false,0,0)));
}

template <class FUNC,class DATA>
inline void add_item_at_top(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
}

template <class FUNC>
inline void add_item_at_top(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func) {
  a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,pos_data>(a_gv,a_widget,a_func,pos_data(false,0,0)));
}

template <class FUNC,class DATA>
inline void add_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
}

template <class FUNC>
inline void add_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,const std::string& a_label,FUNC a_func) {
  a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,pos_data>(a_gv,a_widget,a_func,pos_data(false,0,0)));
}


template <class FUNC,class DATA>
inline void add_image_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_img_file,
                           FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add(a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC,class DATA>
inline void add_image_item_after(gui_viewer& a_gv,list& a_widget,const std::string& a_after,
                                 const std::string& a_label,const std::string& a_img_file,
                                 FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add_after(a_after,a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add_after(a_after,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add_after(a_after,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC,class DATA>
inline void add_image_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                 const std::string& a_label,const std::string& a_img_file,
                                 FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add_before(a_before,a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add_before(a_before,a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC>
inline void add_image_item_before(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                  const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item_before<FUNC,pos_data>(a_gv,a_widget,a_before,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC>
inline void add_image_item_after(gui_viewer& a_gv,list& a_widget,const std::string& a_before,
                                 const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item_after<FUNC,pos_data>(a_gv,a_widget,a_before,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC,class DATA>
inline void add_image_item_at_top(gui_viewer& a_gv,list& a_widget,
                                  const std::string& a_label,const std::string& a_img_file,
                                  FUNC a_func,const DATA& a_data) {
  if(a_gv.m_params.m_image_buttons) {
    img_byte img;
    if(a_gv.set_img_from_res_file(a_img_file,img)) {
      a_widget.add_at_top(a_label,img,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    } else {
      a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
    }
  } else {
    a_widget.add_at_top(a_label,new fundata_cbk<gui_viewer,list,DATA>(a_gv,a_widget,a_func,a_data));
  }
}

template <class FUNC>
inline void add_image_item_at_top(gui_viewer& a_gv,list& a_widget,
                                  const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item_at_top<FUNC,pos_data>(a_gv,a_widget,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC>
inline void add_image_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,const std::string& a_img_file,FUNC a_func) {
  add_image_item<FUNC,pos_data>(a_gv,a_widget,a_label,a_img_file,a_func,pos_data(false,0,0));
}

template <class FUNC,class DATA>
inline void add_white_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func,const DATA& a_data) {
  add_image_item<FUNC,DATA>(a_gv,a_widget,a_label,s_white_jpg(),a_func,a_data);
}

template <class FUNC>
inline void add_white_item(gui_viewer& a_gv,list& a_widget,const std::string& a_label,FUNC a_func) {
  add_white_item<FUNC,pos_data>(a_gv,a_widget,a_label,a_func,pos_data(false,0,0));
}

}}

/////////////////////////////////////////////////////////////////////////////
/// actions : ///////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#include <sys/types.h> //off_t

namespace inlib {
namespace sg {

inline return_action action_none(gui_viewer&) {return return_none;}

#define ACTION_GV_NONE(a__method) \
inline return_action action_##a__method(gui_viewer& a_gv) {\
  a_gv.a__method();\
  return return_none;\
}

#define ACTION_GV_RENDER(a__method) \
inline return_action action_##a__method(gui_viewer& a_gv) {\
  a_gv.a__method();\
  return return_to_render;\
}

#define ACTION_GV_HIDE_MAIN_MENU(a__method) \
inline return_action action_##a__method(gui_viewer& a_gv) {\
  a_gv.a__method();\
  a_gv.hide_main_menu();\
  return return_to_render;\
}

ACTION_GV_NONE(set_to_exit)
ACTION_GV_NONE(clear_caches)
ACTION_GV_NONE(stop_event_anim)

ACTION_GV_RENDER(clear_scene)
ACTION_GV_RENDER(console_mag_two)
ACTION_GV_RENDER(adapt_camera_to_scene)
ACTION_GV_RENDER(toggle_gsto)
ACTION_GV_RENDER(toggle_light)

ACTION_GV_HIDE_MAIN_MENU(reset_camera)
ACTION_GV_HIDE_MAIN_MENU(start_anim_around_focal)
ACTION_GV_HIDE_MAIN_MENU(remove_manips)
ACTION_GV_HIDE_MAIN_MENU(enable_anim)
ACTION_GV_HIDE_MAIN_MENU(disable_anim)

#undef ACTION_GV_NONE
#undef ACTION_GV_RENDER
#undef ACTION_GV_HIDE_MAIN_MENU

inline return_action action_about(gui_viewer& a_gv,const std::vector<std::string>& a_data) {

  sg::text* text = new sg::text(a_gv.ttf());
  a_gv.set_style(*text);

  text->strings = a_data;

  text->confine = true;
  text->hjust = sg::center;

  a_gv.push_list(text);

  return return_to_render;
}

inline return_action action_infos(gui_viewer& a_gv) {
/*
  std::vector<std::string> text;

  text.push_back(" ");
  text.push_back("data_dirs :");
  append(text,a_gv.data_dirs());
  
  text.push_back(" ");
  text.push_back("res_dir :");
  text.push_back(a_gv.res_dir());
  
  text.push_back(" ");
  text.push_back("out_dir :");
  text.push_back(a_gv.out_dir());
  
  text.push_back(" ");
  text.push_back("tmp_dir :");
  text.push_back(a_gv.tmp_dir());
  
  text.push_back(" ");
  text.push_back("pwd :");
  text.push_back(a_gv.pwd());
  
  text.push_back(" ");
  text.push_back("home :");
  text.push_back(dir::home());
  
  text.push_back(" ");
  text.push_back("sizeof(void*) :");
  text.push_back(to(int(sizeof(void*))));

  text.push_back(" ");
  text.push_back("sizeof(long long) :");
  text.push_back(to(int(sizeof(long long))));

  text.push_back(" ");
  text.push_back("little endian :");
  text.push_back(to(is_little_endian()));
  
  a_gv.gui_text(text);
*/

  sg::list* list = new sg::list(a_gv.ttf());
  a_gv.set_style(*list);

 {std::string _s("data : ");
  std::string fdir;
  a_gv.first_data_dir(fdir);
  _s += fdir;
  add_item(a_gv,*list,_s,action_none);}
  
// too long !
//   {std::string _s("res : ");
//    _s += a_gv.res_dir();
//    add_item(a_gv,*list,_s,action_none);}
  
 {std::string _s("out : ");
  _s += a_gv.out_dir();
  add_item(a_gv,*list,_s,action_none);}
  
 {std::string _s("tmp : ");
  _s += a_gv.tmp_dir();
  add_item(a_gv,*list,_s,action_none);}
  
 {std::string _s("pwd : ");
  _s += a_gv.pwd();
  add_item(a_gv,*list,_s,action_none);}
  
 {std::string _s("home : ");
  std::string sh;
  dir::home(sh);
  _s += sh;
  add_item(a_gv,*list,_s,action_none);}
  
 {std::string _s("void* : ");
  if(!numas<uint32>(sizeof(void*),_s)){}
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("long long : ");
  if(!numas<uint32>(sizeof(long long),_s)){}
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("off_t : ");
  if(!numas<uint32>(sizeof(off_t),_s)){}
  add_item(a_gv,*list,_s,action_none);}

 {std::string _s("LI : ");
  bas(is_little_endian(),_s);
  add_item(a_gv,*list,_s,action_none);}

 {std::vector<std::string> _v;
  a_gv.gl_infos(_v);
  inlib_vforcit(std::string,_v,it) add_item(a_gv,*list,*it,action_none);}
  
  a_gv.push_list(list);
    
  return return_to_render;     
}

inline return_action action_set_console(gui_viewer& a_gv,keyboard& a_widget) {
  a_gv.hide_main_menu();
  a_gv.show_console(a_widget.value.value());
  return return_to_render;     
}

inline return_action action_console(gui_viewer& a_gv) {
  keyboard* node = new keyboard(a_gv.ttf());
  a_gv.set_style(*node);
  add_callback(a_gv,*node,action_set_console);
  a_gv.push_list(node);
  return return_to_render;     
}

inline return_action action_show_styles(gui_viewer& a_gv) {
  std::vector<std::string> ltext;
  std::vector<std::string> rtext;
  
 {typedef xml::styles::style_t style_t;
  typedef xml::styles::named_style_t named_style_t;
  const std::vector<named_style_t>& nstys = a_gv.styles().named_styles();
  std::vector<named_style_t>::const_iterator it;
  for(it=nstys.begin();it!=nstys.end();++it) {
    ltext.push_back("//////////////////////////////////////////////////////////////////////////////");
    rtext.push_back(" ");

    ltext.push_back((*it).first+" :");
    rtext.push_back(" ");

    ltext.push_back("//////////////////////////////////////////////////////////////////////////////");
    rtext.push_back(" ");

    const style_t& sty = (*it).second;
    style_t::const_iterator vit;
    for(vit=sty.begin();vit!=sty.end();++vit) {
      //text->lstrings.add((*vit).first);
      //text->rstrings.add((*vit).second);
      ltext.push_back((*vit).first);
      rtext.push_back((*vit).second);
    }
  }}

  a_gv.gui_text(ltext,rtext);
  return return_to_render;
}

inline return_action action_utils(gui_viewer& a_gv) {
  sg::list* list = new sg::list(a_gv.ttf());
  a_gv.set_style(*list);
  
  sg::add_white_item(a_gv,*list,"clear cache",action_clear_caches);
  sg::add_white_item(a_gv,*list,"remove manips",action_remove_manips);
  sg::add_white_item(a_gv,*list,"disable anim",action_disable_anim);
  sg::add_white_item(a_gv,*list,"enable anim",action_enable_anim);
  sg::add_white_item(a_gv,*list,"clear scene",action_clear_scene);
  sg::add_image_item(a_gv,*list,"set console","console.jpg",action_console);
  sg::add_image_item(a_gv,*list,"infos","routing_step.jpg",action_infos);
  sg::add_white_item(a_gv,*list,"styles",action_show_styles);

  a_gv.push_list(list);
    
  return return_to_render;     
}

inline return_action action_open_open_panel(gui_viewer& a_gv,const pos_data& a_data) {
  std::string path;
  if(a_gv.open_panel(path)) {
    args _args;
   {std::string sv;b2s(a_data.m_popup,sv);
    _args.add(s_popup(),sv);
    num2s(a_data.m_ex,sv);
    _args.add(sg::s_ex(),sv);
    num2s(a_data.m_ey,sv);
    _args.add(sg::s_ey(),sv);}

    bool done;
    a_gv.opener().open(path,file::s_format_guessed(),_args,done);
  }
  return return_to_render;
}

inline return_action action_toggle_camera_menu_at_pos(gui_viewer& a_gv,const pos_data& a_data) {
  a_gv.toggle_camera_menu_at_pos(a_data.m_ex,a_data.m_ey);
  return return_to_render;
}

// some common menu item names :
INLIB_GLOBAL_STRING(files)
INLIB_GLOBAL_STRING(export)
INLIB_GLOBAL_STRING(ftp)
INLIB_GLOBAL_STRING(wall)

}}

#include "infos"

namespace inlib {
namespace sg {

inline return_action action_infos_in_console(gui_viewer& a_gv,const pos_data&) {
  search_action sa(a_gv.out());
  const paths_t& paths = find_paths<infos>(sa,a_gv.scene());
  inlib_vforcit(path_t,paths,it) {
    infos* _node = tail<infos>(*it);
    if(_node) {
      std::string _s;
      if(_node->find_keyval(infos::s_title(),_s)) {
        a_gv.show_console(_s);
        return return_to_render;
      }
    }
  }
  return return_none;
}

inline base_camera* astro_pimg_camera(gui_viewer& a_gv,double a_sky_radius) {
  float znear = 1.0f;
  //float angle = fpi()/4.0f;
  //float near_height = 2 * znear * ftan(angle*0.5F);
  float near_height = 5;
  base_camera* camera = a_gv.create_camera(camera_ortho,near_height,znear);
  camera->zfar = float(10*a_sky_radius);
  //camera->position = vec3f(0,0,-20); //at center of the sphere
  camera->position = vec3f(0,0,0); //at center of the sphere
  //camera->orientation = rotf(vec3f(0,1,0),-fhalf_pi());
  //camera->orientation.value() *= rotf(vec3f(1,0,0),-fhalf_pi());
  //camera->orientation.value(camera->orientation.value()*rotf(vec3f(1,0,0),-fhalf_pi()));
  camera->focal = float(a_sky_radius);
  camera->dx = 0.1f;
  camera->da = 0.002f*fdeg2rad();
  return camera;
}

}}

//inlib_build_use kernel

#endif
